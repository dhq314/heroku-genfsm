<feed xmlns="http://www.w3.org/2005/Atom" xml:base="http://dhq.me" xml:lang="en">
	<generator uri="http://zotonic.com/">Zotonic - Atom Feed Module</generator>
	<updated>2013-02-22T22:47:01+08:00</updated>
	<logo />
	<link rel="self" type="application/atom+xml" href="http://dhq.me/feed/article" />
	<id>http://dhq.me/feed/article</id>
	<title>heroku genfsm</title>

    
	
		
	
		<entry xmlns="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005" xml:lang="en">
			<id>http://dhq.me/id/368</id>
			<updated>2013-02-22T22:47:01+08:00</updated>
			<published>2013-02-22T22:34:00+08:00</published>
			<author>
				
				<name>Site Administrator</name>
				<uri>http://dhq.me/id/1</uri>
				
			</author>
			
			<link rel="alternate" type="text/html" href="http://dhq.me/build-compile-eunit-release-erlang-application-with-rebar"/>
			
			
			
			

			<title>用 rebar 来构建、编译、测试、发布 erlang 应用程序</title>
			
				<summary>rebar 是一个遵循 Erlang/OTP 原则的 erlang 项目构建工具，使用它可以减少构建标准 Erlang/OTP 项目架构配置的工作量，并且可以很容易的编译、测试、发布 erlang 应用程序。更强大的是，rebar 提供一种依赖管理机制，它可以使开发者很方便地通过 git、hg 等方式重用常见的第三方 erlang 模块或库</summary>
				<content type="html">&#60;p&#62;&#60;a title=&#34;rebar&#34; href=&#34;https://github.com/basho/rebar&#34; target=&#34;_blank&#34;&#62;rebar&#60;/a&#62; 是一个遵循 Erlang/OTP 原则的 erlang 项目构建工具，使用它可以减少构建标准 Erlang/OTP 项目架构配置的工作量，并且可以很容易的编译、测试、发布 erlang 应用程序。更强大的是，rebar 提供一种依赖管理机制，它可以使开发者很方便地通过 git、hg 等方式重用常见的第三方 erlang 模块或库。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;安装 rebar&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;你可以从 &#60;a title=&#34;pre-build rebar&#34; href=&#34;https://github.com/rebar/rebar/wiki/rebar&#34;&#62;https://github.com/rebar/rebar/wiki/rebar&#60;/a&#62; 下载编译好的版本，也可以自己下载 rebar 的源代码，自己编译一个：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;git clone git://github.com/rebar/rebar.git
cd rebar
./bootstrap
&#60;/pre&#62;&#60;p&#62;上面编译好之后，在当前目录下就会生成一个名为 &#38;quot;rebar&#38;quot; 独立的 erlang 脚本(escript)，把它放在你想创建标准 Erlang/OTP 项目的目录路径下即可使用，或者把 rebar 放在系统目录的 Path 下，方便在终端使用：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;sudo mv rebar /usr/local/bin&#60;/pre&#62;&#60;p&#62;在终端输入 &#38;quot;rebar -c&#38;quot; 将列出所有可执行的 rebar 命令。或者输入 &#38;quot;rebar -h&#38;quot; 查看更多的 rebar 参数信息。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;用 rebar 构建项目&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;创建一个名为 rebarapp 的文件夹&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;mkdir rebarapp
cd rebarapp
&#60;/pre&#62;&#60;p&#62;创建名为 rebarapp 项目：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;rebar create-app appid=rebarapp&#60;/pre&#62;&#60;p&#62;rebar 会根据默认模板（template）在当前目录下生成一个 src 文件夹，里面包含下面3个文件：&#60;/p&#62;&#60;ul&#62;&#60;li&#62;rebarapp.app.src 应用的资源描述文件，影响后面编译生成的 rebarapp.app 里的内容&#60;/li&#62;&#60;li&#62;rebarapp_app.erl 应用的 Application Behaviour 代码文件&#60;/li&#62;&#60;li&#62;rebarapp_sup.erl 应用的 Supervisor Behaviour 代码文件&#60;/li&#62;&#60;/ul&#62;&#60;p&#62;rebar 还内置了 &#60;a title=&#34;erlang gen_server&#34; href=&#34;http://www.erlang.org/doc/design_principles/gen_server_concepts.html&#34; target=&#34;_blank&#34;&#62;gen_server&#60;/a&#62;、&#60;a title=&#34;erlang gen_fsm&#34; href=&#34;http://www.erlang.org/doc/design_principles/fsm.html&#34; target=&#34;_blank&#34;&#62;gen_fsm&#60;/a&#62;、&#60;a title=&#34;erlang application&#34; href=&#34;http://www.erlang.org/doc/design_principles/applications.html&#34; target=&#34;_blank&#34;&#62;application&#60;/a&#62; 等 Erlang/OTP 行为模式的模板，可以自动生成这些行为模式的框架代码。这里以 gen_server 为例，给应用添加一个名为 rebarapp_server 的 gen_server 行为模式。在应用根目录执行以下命令：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;rebar create template=simplesrv srvid=rebarapp_server&#60;/pre&#62;&#60;p&#62;执行完后自动会在 src 文件夹里生成一个 rebarapp_server.erl 的 gen_server 框架格式的文件，simplesrv 是 gen_server 模板的名称(gen_fsm、application对应的是simplefsm、simpleapp)，srvid 则是该 gen_server 模板的ID（gen_fsm、application对应的是fsmid、appid）。&#60;/p&#62;&#60;p&#62;为了测试，这里对 rebarapp_server.erl 进行修改，export 一个 hello 方法，并添加一个 cast 的消息输出，修改后的 rebarapp_server.erl 文件内容如下：&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;-module(rebarapp_server).
-behaviour(gen_server).
-define(SERVER, ?MODULE).

%% ------------------------------------------------------------------
%% API Function Exports
%% ------------------------------------------------------------------

-export([start_link/0, hello/0]).

%% ------------------------------------------------------------------
%% gen_server Function Exports
%% ------------------------------------------------------------------

-export([init/1, handle_call/3, handle_cast/2, handle_info/2,
         terminate/2, code_change/3]).

%% ------------------------------------------------------------------
%% API Function Definitions
%% ------------------------------------------------------------------

start_link() -&#38;gt;
    gen_server:start_link({local, ?SERVER}, ?MODULE, [], []).

%% @doc just a test
hello() -&#38;gt;
    gen_server:cast(?SERVER, &#38;#39;HELLO&#38;#39;).

%% ------------------------------------------------------------------
%% gen_server Function Definitions
%% ------------------------------------------------------------------

init(Args) -&#38;gt;
    {ok, Args}.

handle_call(_Request, _From, State) -&#38;gt;
    {reply, ok, State}.

handle_cast(&#38;#39;HELLO&#38;#39;, State) -&#38;gt;
    io:format(&#38;quot;Hello World!~n&#38;quot;),
    {noreply, State};

handle_cast(_Msg, State) -&#38;gt;
    {noreply, State}.

handle_info(_Info, State) -&#38;gt;
    {noreply, State}.

terminate(_Reason, _State) -&#38;gt;
    ok.

code_change(_OldVsn, State, _Extra) -&#38;gt;
    {ok, State}.

%% ------------------------------------------------------------------
%% Internal Function Definitions
%% ------------------------------------------------------------------
&#60;/pre&#62;&#60;p&#62;修改 rebarapp_sup.erl 的 init 函数，把 rebarapp_server 作为应用管理者 rebarapp_sup 的工作进程启动，修改如下：&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;init([]) -&#38;gt;
    RebarappServer = ?CHILD(rebarapp_server, worker),
    {ok, { {one_for_one, 5, 10}, [RebarappServer]} }.
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;编译应用&#60;/strong&#62;&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;rebar compile&#60;/pre&#62;&#60;p&#62;编译完后，会在根目录下生成一个 ebin 的文件夹，里面存放的是该应用的资源文件 rebarapp.app 和应用的 beam 文件，也可以执行以下命令对编译生成的应用文件进行清理：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;rebar clean&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;使用 Edoc 生成应用文档&#60;/strong&#62;&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;rebar doc&#60;/pre&#62;&#60;p&#62;命令执行完后，会在根目录生成一个 doc 的文件夹，打开里面的 index.html 就可以很直观地看到该应用的模块 API 概览。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;eunit 测试&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;rebar 会根据一个名为 rebar.config 的文件里的 &#60;a title=&#34;erlang eunit&#34; href=&#34;http://www.erlang.org/doc/man/eunit.html&#34; target=&#34;_blank&#34;&#62;eunit&#60;/a&#62; 配置选项来对应用进行测试，rebar.config 详细地配置选项信息可以查看官方上的 &#60;a title=&#34;rebar.config.sample&#34; href=&#34;https://github.com/basho/rebar/blob/master/rebar.config.sample&#34; target=&#34;_blank&#34;&#62;rebar.config.sample&#60;/a&#62;。在应用的根目录下创建一个 rebar.config，填入以下内容：&#60;/p&#62;&#60;pre class=&#34;brush: plain&#34;&#62;%%-*- mode: erlang -*-

%% Erlang compiler options
{erl_opts, [debug_info,
            {i, &#38;quot;test&#38;quot;},
            {src_dirs, [&#38;quot;src&#38;quot;]}]}.

{eunit_opts, [verbose, {report, {eunit_surefire, [{dir, &#38;quot;.&#38;quot;}]}}]}.

{cover_enabled, true}.
&#60;/pre&#62;&#60;p&#62;上面的配置将会加载根目录下的 test 文件夹里的文件，所以需要在根目录下创建一个 test 文件夹：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;mkdir -p test&#60;/pre&#62;&#60;p&#62;这里 test 文件夹将存放 eunit 的测试用例，在 test 文件夹里新建一个名为 rebarapp_test.hrl 的测试用例文件，内容如下：&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;-include_lib(&#38;quot;eunit/include/eunit.hrl&#38;quot;).


my_test() -&#38;gt;
    ?assert(1 + 2 =:= 3).

simple_test() -&#38;gt;
    ok = application:start(rebarapp),
    ?assertNot(undefined =:= whereis(rebarapp_sup)).
&#60;/pre&#62;&#60;p&#62;然后在 rebarapp_server.erl 的文件末尾加上以下测试代码：&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;-ifdef(TEST).
-include(&#38;quot;rebarapp_test.hrl&#38;quot;).
-endif.
&#60;/pre&#62;&#60;p&#62;当然，如果有必要的话也可以在每个模块文件上加上面测试代码。执行以下命令进行 eunit 测试：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;rebar compile eunit&#60;/pre&#62;&#60;p&#62;如果应用文件没什么变化修改，也可以直接运行 &#38;quot;rebar eunit&#38;quot;。这时终端出现以下类似显示，则 eunit 测试完成：&#60;/p&#62;&#60;pre class=&#34;brush: plain&#34;&#62;==&#38;gt; rebarapp (eunit)
======================== EUnit ========================
module &#38;#39;rebarapp_app&#38;#39;
module &#38;#39;rebarapp_server&#38;#39;
  rebarapp_server: my_test...ok
  rebarapp_server: simple_test...[0.014 s] ok
  [done in 0.019 s]
module &#38;#39;rebarapp_sup&#38;#39;
=======================================================
  All 2 tests passed.
Cover analysis: /Users/dengjoe/erlang/rebarapp/.eunit/index.html
&#60;/pre&#62;&#60;p&#62;可以打开根目录下的.eunit/index.html 查看测试报告。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;发布应用&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;在应用根目录下创建一个名为 rel 的文件夹，用来作为应用发布的文件夹：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;mkdir -p rel
cd rel
&#60;/pre&#62;&#60;p&#62;在当前 rel 文件夹里创建一个名为 rebarapp 的独立的 Erlang VM 节点：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;rebar create-node nodeid=rebarapp&#60;/pre&#62;&#60;p&#62;修改 rel/reltool.config 里的 lib_dirs 的值，默认是一个空列表 &#38;quot;[]&#38;quot;，改为应用所在的目录路径 &#38;#39;[&#38;quot;../../&#38;quot;]&#38;#39;，不然到后面编译发布时会报 &#38;quot;Missing application directory&#38;quot; 的错误出来，修改后的 reltool.config 配置内容如下所示：&#60;/p&#62;&#60;pre class=&#34;brush: plain&#34;&#62;{sys, [
       {lib_dirs, [&#38;quot;../../&#38;quot;]},
       {erts, [{mod_cond, derived}, {app_file, strip}]},
       {app_file, strip},
       {rel, &#38;quot;rebarapp&#38;quot;, &#38;quot;1&#38;quot;,
        [
         kernel,
         stdlib,
         sasl,
         rebarapp
        ]},
       {rel, &#38;quot;start_clean&#38;quot;, &#38;quot;&#38;quot;,
        [
         kernel,
         stdlib
        ]},
       {boot_rel, &#38;quot;rebarapp&#38;quot;},
       {profile, embedded},
       {incl_cond, derived},
       {mod_cond, derived},
       {excl_archive_filters, [&#38;quot;.*&#38;quot;]}, %% Do not archive built libs
       {excl_sys_filters, [&#38;quot;^bin/.*&#38;quot;, &#38;quot;^erts.*/bin/(dialyzer|typer)&#38;quot;,
                           &#38;quot;^erts.*/(doc|info|include|lib|man|src)&#38;quot;]},
       {excl_app_filters, [&#38;quot;\.gitignore&#38;quot;]},
       {app, rebarapp, [{mod_cond, app}, {incl_cond, include}]}
      ]}.

{target_dir, &#38;quot;rebarapp&#38;quot;}.

{overlay, [
           {mkdir, &#38;quot;log/sasl&#38;quot;},
           {copy, &#38;quot;files/erl&#38;quot;, &#38;quot;\{\{erts_vsn\}\}/bin/erl&#38;quot;},
           {copy, &#38;quot;files/nodetool&#38;quot;, &#38;quot;\{\{erts_vsn\}\}/bin/nodetool&#38;quot;},
           {copy, &#38;quot;files/rebarapp&#38;quot;, &#38;quot;bin/rebarapp&#38;quot;},
           {copy, &#38;quot;files/rebarapp.cmd&#38;quot;, &#38;quot;bin/rebarapp.cmd&#38;quot;},
           {copy, &#38;quot;files/start_erl.cmd&#38;quot;, &#38;quot;bin/start_erl.cmd&#38;quot;},
           {copy, &#38;quot;files/install_upgrade.escript&#38;quot;, &#38;quot;bin/install_upgrade.escript&#38;quot;},
           {copy, &#38;quot;files/sys.config&#38;quot;, &#38;quot;releases/\{\{rel_vsn\}\}/sys.config&#38;quot;},
           {copy, &#38;quot;files/vm.args&#38;quot;, &#38;quot;releases/\{\{rel_vsn\}\}/vm.args&#38;quot;}
          ]}.
&#60;/pre&#62;&#60;p&#62;返回应用的根目录，在 rebar.config 加上以下一行，把新建的 rel 文件夹放入到 rebar 可访问的子文件夹里，作为应用内容发布文件夹： &#60;/p&#62;&#60;pre class=&#34;brush: plain&#34;&#62;{sub_dirs, [&#38;quot;rel&#38;quot;]}.&#60;/pre&#62;&#60;p&#62;再重新编译下应用 rebarapp&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;rebar compile&#60;/pre&#62;&#60;p&#62;如果报什么错，应用 rebarapp 就可以发布了：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;rebar generate&#60;/pre&#62;&#60;p&#62;在终端上看到 &#38;quot;==&#38;gt; rel (generate)&#38;quot; 且没报什么错，应用 rebarapp 发布成功，并在 rel/rebarapp/bin 目录下生成一个用来启动应用或停止应用等操控动作的 shell 文件 rebarapp。&#60;/p&#62;&#60;p&#62;操控文件 rel/rebarapp/bin/rebarapp 用法：&#60;/p&#62;&#60;pre class=&#34;brush: plain&#34;&#62;rebarapp {start|start_boot |foreground|stop|restart|reboot|ping|console|console_clean|console_boot |attach|remote_console|upgrade}&#60;/pre&#62;&#60;p&#62;例如：&#60;/p&#62;&#60;p&#62;启动应用 rebarapp&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;rel/rebarapp/bin/rebarapp start&#60;/pre&#62;&#60;p&#62;停止应用 rebarapp&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;rel/rebarapp/bin/rebarapp stop&#60;/pre&#62;&#60;p&#62;或者启动应用 rebarapp 后返回一个 erlang shell 的控制台&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;rel/rebarapp/bin/rebarapp console&#60;/pre&#62;&#60;p&#62;OK，在 erlang shell 的控制台上调用 rebarapp_server:hello() 输出一个 &#38;quot;Hello World!&#38;quot; 吧。&#60;/p&#62;</content>
			
			
			
			
				
			<category term="article" scheme="http://zotonic.com/id/category" />
		</entry>
	


	
		
	
		<entry xmlns="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005" xml:lang="en">
			<id>http://dhq.me/id/364</id>
			<updated>2013-02-21T14:43:46+08:00</updated>
			<published>2013-02-18T16:41:00+08:00</published>
			<author>
				
				<name>Site Administrator</name>
				<uri>http://dhq.me/id/1</uri>
				
			</author>
			
			<link rel="alternate" type="text/html" href="http://dhq.me/heroku-deploy-erlang-web-webmachine-mochiweb-erlydtl"/>
			
			
			
			

			<title>在 heroku 上部署 webmachine + mochiweb + erlydtl 组合的Erlang Web应用</title>
			
				<summary>最近在看 zotonic 的 webmachine 的代码，恰好在网上找到一篇在 heroku 上部署 webmachine 的文章。为了可以剥开庞大的 zotonic 代码，可以更清晰地独立查看研究 webmachine 的代码，也加上之前也没玩过 heroku 这个 Paas(Platform as a service) 云服务应用平台，所以就参考那篇文章，在 heroku 也部署了自己的一个 Erlang Web 应用</summary>
				<content type="html">&#60;p&#62;最近在看 &#60;a title=&#34;zotonic 在 Ubuntu 下的安装配置&#34; href=&#34;http://dhq.me/unbuntu-install-zotonic&#34;&#62;zotonic&#60;/a&#62; 的 &#60;a title=&#34;webmachine&#34; href=&#34;https://github.com/basho/webmachine&#34; target=&#34;_blank&#34;&#62;webmachine&#60;/a&#62; 的代码，恰好在网上找到一篇在 &#60;a title=&#34;Heroku&#34; href=&#34;http://www.heroku.com/&#34; target=&#34;_blank&#34;&#62;heroku&#60;/a&#62; 上部署 webmachine 的&#60;a title=&#34;Running Erlang Webmachine on Heroku&#34; href=&#34;http://zianet.dk/blog/2011/12/16/running-erlang-webmachine-on-heroku/&#34; target=&#34;_blank&#34;&#62;文章&#60;/a&#62;。为了可以剥开庞大的 zotonic 代码，可以更清晰地独立查看研究 webmachine 的代码，也加上之前也没玩过 heroku 这个 Paas(Platform as a service) 云服务应用平台，所以就参考那篇文章，在 heroku 也部署了自己的一个 &#60;a title=&#34;heroku genfsm&#34; href=&#34;http://genfsm.herokuapp.com/&#34; target=&#34;_blank&#34;&#62;Erlang Web 应用&#60;/a&#62;。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;安装配置 heroku 的开发环境&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;如果还没有 heroku 账号，先&#60;a title=&#34;Heroku Login&#34; href=&#34;https://api.heroku.com/signup/devcenter&#34; target=&#34;_blank&#34;&#62;注册&#60;/a&#62;一个。接着安装 heroku 的本地开发工具 -- Toolbelt，打开 &#60;a title=&#34;Heroku Toolbelt&#34; href=&#34;https://toolbelt.heroku.com/&#34; target=&#34;_blank&#34;&#62;Heroku Toolbelt&#60;/a&#62; 主页，下载相应操作系统（以下操作都是在 mac 系统下进行）的安装文件，根据安装提示和自己的安装癖好一直点就行。&#60;/p&#62;&#60;p&#62;Toolbelt 安装好后，在终端上输入：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;heroku login&#60;/pre&#62;&#60;p&#62;根据提示输入刚才注册的邮箱名和密码，并在接着出现的提示框中按回车键来上传现有存在的 ssh 密钥或者是创建一个新的 ssh 密钥。最后在终端里出现 &#38;quot;Authentication successful&#38;quot; 后，本地的heroku开发环境算配置完成。&#60;/p&#62;&#60;p&#62;详细的 heroku 开发环境配置，可以参看官方的配置指南 -- 《&#60;a title=&#34;Getting Started with Heroku&#34; href=&#34;https://devcenter.heroku.com/articles/quickstart&#34; target=&#34;_blank&#34;&#62;Getting Started with Heroku&#60;/a&#62;》。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;安装webmachine&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;在终端上 cd 到你想安装的文件目录里（这里以当前用户目录下的 erlang 文件夹 &#38;quot;~/erlang/&#38;quot; 为例），并确保已经安装了 git 环境&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;git clone git://github.com/basho/webmachine
cd webmachine
make
&#60;/pre&#62;&#60;p&#62;这里以 genfsm 为应用名，创建一个 webmachine 实例应用，并把实例应用放在新创建的 heroku 文件夹里：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;mkdir -p ./heroku
./scripts/new_webmachine.sh genfsm ./heroku
cd ./heroku/genfsm
make
&#60;/pre&#62;&#60;p&#62;在终端里运行 &#38;quot;./start.sh&#38;quot;，然后在浏览器上输入 &#38;quot;&#60;a href=&#34;http://localhost:8000/&#34; target=&#34;_blank&#34;&#62;http://localhost:8000/&#60;/a&#62;&#38;quot;，就可以看到 webmachine 的欢迎页面了。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;部署应用到 heroku 上&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;在 genfsm 的应用根目录（&#38;quot;~/erlang/webmachine/heroku/genfsm&#38;quot;）里初始一个新的 git 版本仓库：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;git init&#60;/pre&#62;&#60;p&#62;创建以 genfsm 为应用名的 heroku 应用：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;heroku create genfsm -s cedar
&#60;/pre&#62;&#60;p&#62;这里选择 &#60;a title=&#34;heroku cedar&#34; href=&#34;https://devcenter.heroku.com/articles/cedar&#34; target=&#34;_blank&#34;&#62;cedar&#60;/a&#62; 作为该应用的运行时环境(runtime stack)。当在终端出现以下显示时，应用创建成功：&#60;/p&#62;&#60;pre class=&#34;brush: plain&#34;&#62;Creating genfsm... done, stack is cedar
http://genfsm.herokuapp.com/ | git@heroku.com:genfsm.git
Git remote heroku added
&#60;/pre&#62;&#60;p&#62;&#38;quot;&#60;a title=&#34;heroku genfsm&#34; href=&#34;http://genfsm.herokuapp.com/&#34; target=&#34;_blank&#34;&#62;http://genfsm.herokuapp.com/&#60;/a&#62;&#38;quot; 是该应用的访问地址，&#38;quot;git@heroku.com:genfsm.git&#38;quot; 是该应用的 git 地址。&#60;/p&#62;&#60;p&#62;设置该应用 genfsm 为 erlang 的&#60;a title=&#34;heroku buildpack&#34; href=&#34;https://devcenter.heroku.com/articles/buildpacks&#34; target=&#34;_blank&#34;&#62;构建包(buildpack)&#60;/a&#62;，这里使用官方发布的 &#60;a title=&#34;heroku erlang buildpack&#34; href=&#34;https://github.com/heroku/heroku-buildpack-erlang&#34; target=&#34;_blank&#34;&#62;erlang 构建包&#60;/a&#62;：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;heroku config:add BUILDPACK_URL=http://github.com/heroku/heroku-buildpack-erlang.git
&#60;/pre&#62;&#60;p&#62;修改 rebar.config 文件配置，添加 &#60;a title=&#34;ErlyDTL&#34; href=&#34;https://github.com/evanmiller/erlydtl&#34; target=&#34;_blank&#34;&#62;ErlyDTL&#60;/a&#62; 模板依赖： &#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;%%-*- mode: erlang -*-
{sub_dirs, [&#38;quot;rel&#38;quot;]}.
{deps_dir, [&#38;quot;deps&#38;quot;]}.
{erl_opts, [debug_info]}.

{deps, [
            {webmachine, &#38;quot;1.9.*&#38;quot;, {git, &#38;quot;git://github.com/basho/webmachine&#38;quot;, &#38;quot;HEAD&#38;quot;}},
            {erlydtl, &#38;quot;.*&#38;quot;, {git, &#38;quot;git://github.com/evanmiller/erlydtl.git&#38;quot;, &#38;quot;master&#38;quot;}}
        ]

}.
&#60;/pre&#62;&#60;p&#62;在 genfsm 应用根目录下创建一个 templates 文件夹，用来存放应用的模板文件。&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;mkdir -p ./templates&#60;/pre&#62;&#60;p&#62;在 templates 文件夹里创建一个 genfsm.dtl 模板文件，输入以下内容：&#60;/p&#62;&#60;pre class=&#34;brush: html&#34;&#62;&#38;lt;!DOCTYPE html&#38;gt;
&#38;lt;html&#38;gt;
&#38;lt;head&#38;gt;
&#38;lt;meta http-equiv=&#38;quot;Content-Type&#38;quot; content=&#38;quot;text/html; charset=UTF-8&#38;quot; /&#38;gt;
&#38;lt;title&#38;gt;{{application_name}}&#38;lt;/title&#38;gt;
&#38;lt;style type=&#38;quot;text/css&#38;quot;&#38;gt;
body { margin: 0; padding: 0; }
p { margin: 3px 0; font-size: 22px; }
a, a:active { color: #00A9DA; }
a:hover { text-decoration: none; }
&#38;lt;/style&#38;gt;
&#38;lt;/head&#38;gt;
&#38;lt;body&#38;gt;
    &#38;lt;div style=&#38;quot;text-align: center;&#38;quot;&#38;gt;
        &#38;lt;h1&#38;gt;Hi, welcome to my heroku erlang app!&#38;lt;h1&#38;gt;
        &#38;lt;div style=&#38;quot;width: 650px; margin: 0 auto; text-align: left;&#38;quot;&#38;gt;
            &#38;lt;h2 style=&#38;quot;text-align: center;&#38;quot;&#38;gt;Status&#38;lt;/h2&#38;gt;
            &#38;lt;p&#38;gt;AppName：{{application_name}}&#38;lt;/p&#38;gt;
            &#38;lt;p&#38;gt;Port：{{port}}&#38;lt;/p&#38;gt;
            &#38;lt;p&#38;gt;SchedulerId：{{scheduler_id}}&#38;lt;/p&#38;gt;
            &#38;lt;p&#38;gt;SchedulerNum：{{scheduler_num}}&#38;lt;/p&#38;gt;
            &#38;lt;p&#38;gt;ProcessCount：{{process_count}}&#38;lt;/p&#38;gt;
            &#38;lt;p&#38;gt;ProcessLimit：{{process_limit}}&#38;lt;/p&#38;gt;
            &#38;lt;p&#38;gt;Memory used by erlang processes：{{processes_used}}&#38;lt;/p&#38;gt;
            &#38;lt;p&#38;gt;Memory allocated by erlang processes：{{processes}}&#38;lt;/p&#38;gt;
            &#38;lt;p&#38;gt;The total amount of memory allocated：{{memtotal}}&#38;lt;/p&#38;gt;
            &#38;lt;p&#38;gt;OTP Version：{{otp_release}}&#38;lt;/p&#38;gt;
            &#38;lt;p&#38;gt;OS：{{os}}&#38;lt;/p&#38;gt;
            &#38;lt;p&#38;gt;ClientIp：{{client_ip}}&#38;lt;/p&#38;gt;
            &#38;lt;p&#38;gt;IntranetIp：{{intranet_ip}}&#38;lt;/p&#38;gt;
            &#38;lt;p&#38;gt;RequestTime：{{request_time}}&#38;lt;/p&#38;gt;
            &#38;lt;p&#38;gt;Blog：&#38;lt;a href=&#38;quot;http://dhq.me/&#38;quot;&#38;gt;D.H.Q的烂笔头&#38;lt;/a&#38;gt;&#38;lt;/p&#38;gt;
        &#38;lt;/div&#38;gt;
    &#38;lt;/div&#38;gt;
&#38;lt;/body&#38;gt;
&#38;lt;/html&#38;gt;
&#60;/pre&#62;&#60;p&#62;修改 src/genfsm_resource.erl 里的 to_html 函数，调用上面创建的 genfsm.dtl 模板文件作为返回显示，修改如下：&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;%% @author author &#38;lt;author@example.com&#38;gt;
%% @copyright YYYY author.
%% @doc Example webmachine_resource.

-module(genfsm_resource).
-export([init/1, to_html/2]).

-include_lib(&#38;quot;webmachine/include/webmachine.hrl&#38;quot;).
-include_lib(&#38;quot;webmachine/include/wm_reqstate.hrl&#38;quot;).

init([]) -&#38;gt; {ok, undefined}.

to_html(ReqData, State) -&#38;gt;
    %io:format(&#38;quot;~p~n~n~n&#38;quot;, [ReqData]),
    {ok, ApplicationName} = application:get_application(?MODULE),
    Port = 
        case os:getenv(&#38;quot;PORT&#38;quot;) of
            false -&#38;gt;
                case os:getenv(&#38;quot;WEBMACHINE_PORT&#38;quot;) of
                    false -&#38;gt; 8000;
                    AnyPort -&#38;gt; AnyPort
                end;
            AnyPort -&#38;gt; list_to_integer(AnyPort)
        end,

    SchedulerId = erlang:system_info(scheduler_id),
    SchedulerNum = erlang:system_info(schedulers),
    ProcessCount = erlang:system_info(process_count),
    ProcessLimit = erlang:system_info(process_limit),
    ProcessesMemUsed = erlang:memory(processes_used),
    ProcessesMemAlloc = erlang:memory(processes),
    MemTotal = erlang:memory(total),

    OTP = erlang:system_info(otp_release),
    OS = io_lib:format(&#38;quot;~p&#38;quot;, [erlang:system_info(os_type)]),

    {{Year, Month, Day}, {Hour, Minute, Second}} = calendar:local_time(),
    RequestTime = io_lib:format(&#38;quot;~p-~p-~p ~p:~p:~p&#38;quot;, [Year, Month, Day, Hour, Minute, Second]),

    Socket = ReqData#wm_reqdata.wm_state#wm_reqstate.socket,
    Ip = get_ip(Socket),

    HtmlData = [
        {application_name, ApplicationName}, 
        {port, Port},
        {scheduler_id, SchedulerId},
        {scheduler_num, SchedulerNum},
        {process_count, ProcessCount},
        {process_limit, ProcessLimit},
        {processes_used, ProcessesMemUsed},
        {processes, ProcessesMemAlloc},
        {memtotal, MemTotal},
        {otp_release, OTP},
        {os, OS},
        {client_ip, ReqData#wm_reqdata.peer}, 
        {intranet_ip, io_lib:format(&#38;quot;~p&#38;quot;, [Ip])},
        {request_time, RequestTime}
    ],

    {ok, Html} = genfsm_dtl:render(HtmlData),
    {Html, ReqData, State}.


get_ip(Socket) -&#38;gt;
    case inet:peername(Socket) of
        {ok, {Ip, _Port}} -&#38;gt; Ip;
        {error, _Reason} -&#38;gt; {0,0,0,0}
    end.
&#60;/pre&#62;&#60;p&#62;修改 src/genfsm_sup.erl 里的 init 函数，设置应用监听的端口(Port)，把应用 ip 设置为 &#38;quot;0.0.0.0&#38;quot;，并把日志目录选项注释掉，修改如下：&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;%% @spec init([]) -&#38;gt; SupervisorTree
%% @doc supervisor callback.
init([]) -&#38;gt;
    %Ip = case os:getenv(&#38;quot;WEBMACHINE_IP&#38;quot;) of false -&#38;gt; &#38;quot;0.0.0.0&#38;quot;; Any -&#38;gt; Any end,
    {ok, App} = application:get_application(?MODULE),
    {ok, Dispatch} = file:consult(filename:join([priv_dir(App),
                                                 &#38;quot;dispatch.conf&#38;quot;])),
    %Port = case os:getenv(&#38;quot;WEBMACHINE_PORT&#38;quot;) of
     %      false -&#38;gt; 8000;
      %     AnyPort -&#38;gt; AnyPort
       %   end,
    Port = list_to_integer(os:getenv(&#38;quot;PORT&#38;quot;)),
    WebConfig = [
                 {ip, &#38;quot;0.0.0.0&#38;quot;},
                 %{ip, Ip},
                 {port, Port},
                 %{log_dir, &#38;quot;priv/log&#38;quot;},
                 {dispatch, Dispatch}],
    Web = {webmachine_mochiweb,
           {webmachine_mochiweb, start, [WebConfig]},
           permanent, 5000, worker, [mochiweb_socket_server]},
    Processes = [Web],
    {ok, { {one_for_one, 10, 10}, Processes} }.
&#60;/pre&#62;&#60;p&#62;在 genfsm 的应用根目录下创建一个以 &#60;a title=&#34;heroku procfile&#34; href=&#34;https://devcenter.heroku.com/articles/procfile&#34; target=&#34;_blank&#34;&#62;Procfile&#60;/a&#62; 命名的文件，填入以下内容，声明应用在启动前该执行的指令：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;web: erl -pa ebin deps/*/ebin -noshell -boot start_sasl -s reloader -s genfsm
&#60;/pre&#62;&#60;p&#62;可以在终端里输入以下编译命令：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;./rebar get-deps compile&#60;/pre&#62;&#60;p&#62;编译下应用，检查是否有语法之类的错误。如果编译成功，则应用的本地配置完成，可以把要发布的文件或文件夹添加到版本库里：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;git add Makefile Procfile README rebar rebar.config start.sh src/* priv/dispatch.conf templates/*
git commit -m &#38;quot;heroku genfsm&#38;quot;
&#60;/pre&#62;&#60;p&#62;最后，把应用发布到 heroku 上：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;git push heroku master
&#60;/pre&#62;&#60;p&#62;上面命令会把本地应用的代码提交到远程 heroku 服务器上，并编译代码，启动应用 genfsm。当在终端里出现 &#38;quot;http://genfsm.herokuapp.com deployed to Heroku&#38;quot; 的字样时，则应用 genfsm 在 heroku 上发布启动成功，可以在浏览器里打开 &#60;a title=&#34;heroku genfsm&#34; href=&#34;http://genfsm.herokuapp.com&#34; target=&#34;_blank&#34;&#62;http://genfsm.herokuapp.com&#60;/a&#62; 访问了。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;遇到的问题&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;&#38;quot;&#38;#39;heroku&#38;#39; does not appear to be a git repository&#38;quot;&#60;/p&#62;&#60;p&#62;可能是 .git 文件夹里的配置文件出错了吧，执行 &#38;quot;git push heroku master&#38;quot; 就报这个错，不过执行以下命令，重新指定 git 源后问题解决：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;git remote add heroku git@heroku.com:genfsm.git
git remote -v
&#60;/pre&#62;</content>
			
			
			
			
				
			<category term="article" scheme="http://zotonic.com/id/category" />
		</entry>
	


	
		
	
		<entry xmlns="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005" xml:lang="en">
			<id>http://dhq.me/id/362</id>
			<updated>2013-01-21T16:06:52+08:00</updated>
			<published>2013-01-21T15:52:00+08:00</published>
			<author>
				
				<name>Site Administrator</name>
				<uri>http://dhq.me/id/1</uri>
				
			</author>
			
			<link rel="alternate" type="text/html" href="http://dhq.me/zotonic-module-mod_html_sitemap"/>
			
			
			
			

			<title>zotonic模块制作 -- HTML Sitemap</title>
			
				<summary>其实 zotonic 已经有一个sitemap 的模块 -- mod_seo_sitemap，在 /moudules/mod_seo_sitemap 目录下，不过这个模块只生成 xml 格式的 sitemap，不方便浏览。恰好之前了解了下zotonic模块结构 一些相关知识，学以致用，所以就仿照 mod_seo_sitemap 模块，做一个 HTML 版的sitemap -- mod_html_sitemap</summary>
				<content type="html">&#60;p&#62;其实 zotonic 已经有一个sitemap 的模块 -- mod_seo_sitemap，在 /moudules/mod_seo_sitemap 目录下，不过这个模块只生成 xml 格式的 &#60;a title=&#34;D.H.Q xml sitemap&#34; href=&#34;dhq.me/sitemap.xml&#34; target=&#34;_blank&#34;&#62;sitemap&#60;/a&#62;，不方便浏览。恰好之前了解了下&#60;a title=&#34;zotonic的模块结构&#34; href=&#34;http://dhq.me/zotonic-module-structure&#34;&#62;zotonic模块结构&#60;/a&#62; 一些相关知识，学以致用，所以就仿照 mod_seo_sitemap 模块，做一个 HTML 版的sitemap -- mod_html_sitemap。&#60;/p&#62;&#60;p&#62;下面是 mod_html_sitemap 模块的目录结构图：&#60;/p&#62;&#60;pre class=&#34;brush: text&#34;&#62;|----mod_sitemap_html
| |----dispatch
| | |----dispatch
| |----mod_sitemap_html.erl
| |----templates
| | |----_sitemap_html.tpl
| | |----sitemap_html.tpl
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;mod_sitemap_html&#60;/strong&#62;:&#60;/p&#62;&#60;p&#62;以 mod_sitemap_html 为命名的模块文件夹。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;mod_sitemap_html.erl&#60;/strong&#62;:&#60;/p&#62;&#60;p&#62;模块的初始文件，跟模块名一样。定义模块的一些初始信息，例如模块标题、作者、描述、权值(priority)等等，这些信息将作为模块的描述信息出现在后台模块管理页面上。&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;-module(mod_sitemap_html).
-author(&#38;quot;Joe Deng &#38;lt;dhq314@gmail.com&#38;gt;&#38;quot;).

-mod_title(&#38;quot;HTML Sitemap&#38;quot;).
-mod_description(&#38;quot;Generates sitemap for a friendly view.&#38;quot;).
-mod_prio(600).
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;dispatch/dispatch&#60;/strong&#62;&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;%% -*- mode: erlang -*-
[
	{sitemap_html, [&#38;quot;sitemap.html&#38;quot;], controller_template, [{template, &#38;quot;sitemap_html.tpl&#38;quot;}, {content_type, &#38;quot;text/html&#38;quot;}, {anonymous, true}]}
].
&#60;/pre&#62;&#60;p&#62;sitemap_html: 该路由调度规则的名称标识&#60;/p&#62;&#60;p&#62;[&#38;quot;sitemap.html&#38;quot;]: 匹配来自 sitemap.html 的url请求&#60;/p&#62;&#60;p&#62;controller_template: 使用 controller_template 作为模板控制器&#60;/p&#62;&#60;p&#62;[{template, &#38;quot;sitemap_html.tpl&#38;quot;}, {content_type, &#38;quot;text/html&#38;quot;}, {anonymous, true}]: 标识模板路径，以及该模板内容形式，并允许匿名访问&#60;/p&#62;&#60;p&#62;URL路由调度规则 dispatch 的更多信息可以查看&#60;a title=&#34;zotonic dispatch&#34; href=&#34;http://zotonic.com/docs/latest/manuals/dispatch.html&#34; target=&#34;_blank&#34;&#62;这里&#60;/a&#62;。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;templates/sitemap_html.tpl&#60;/strong&#62;&#60;/p&#62;&#60;pre class=&#34;brush: html&#34;&#62;{% cache 3600 sitemap_html cat=&#38;quot;article&#38;quot; %}
	{% with m.search[{query cat=&#38;quot;article&#38;quot; is_published=&#38;#39;true&#38;#39; sort=&#38;#39;-rsc.publication_start&#38;#39;}] as result %}
		{% include &#38;quot;_sitemap_html.tpl&#38;quot; %}
	{% endwith %}
{% endcache %}
&#60;/pre&#62;&#60;p&#62;这里使用了 &#60;a title=&#34;ErlyDTL&#34; href=&#34;http://zotonic.com/page/520/erlydtl&#34; target=&#34;_blank&#34;&#62;ErlyDTL&#60;/a&#62; 的模板缓存 &#60;a title=&#34;ErlyDTL cache&#34; href=&#34;http://zotonic.com/docs/latest/ref/tags/tag_cache.html&#34; target=&#34;_blank&#34;&#62;cache&#60;/a&#62;，缓存时间是一个小时(3600秒)，sitemap_html是该缓存名。并使用 &#60;a title=&#34;zotonic m_search model&#34; href=&#34;http://zotonic.com/documentation/726/m-search&#34; target=&#34;_blank&#34;&#62;m_search&#60;/a&#62; 模型方法，把类型是 article 的已发布的文章，按文章发布日期(publication_start，rsc表的一个字段)的倒序查询出来。cat、is_published、sort是查询模式 query 的选项，更多的选项说明可以查看&#60;a title=&#34;zotonic m_search option&#34; href=&#34;http://zotonic.com/documentation/761/the-query-search-model&#34; target=&#34;_blank&#34;&#62;这里&#60;/a&#62;。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;templates/_sitemap_html.tpl&#60;/strong&#62;&#60;/p&#62;&#60;pre class=&#34;brush: html;&#34;&#62;&#38;lt;!DOCTYPE html&#38;gt;
&#38;lt;html&#38;gt;
&#38;lt;meta http-equiv=&#38;quot;Content-Type&#38;quot; content=&#38;quot;text/html; charset=UTF-8&#38;quot; /&#38;gt;
&#38;lt;title&#38;gt;SiteMap - {{ m.config.site.title.value }}&#38;lt;/title&#38;gt;
&#38;lt;meta name=&#38;quot;keywords&#38;quot; content=&#38;quot;SiteMap,{{ m.config.site.title.value }}&#38;quot; /&#38;gt;
&#38;lt;link rel=&#38;quot;profile&#38;quot; href=&#38;quot;http://gmpg.org/xfn/11&#38;quot; /&#38;gt;
&#38;lt;style type=&#38;quot;text/css&#38;quot;&#38;gt;
body {
	margin: 0;
	font-family: Verdana;
	font-size: 12px;
}
a, a:visited {
	color: #333333;
}
li {
	margin-top: 8px;
}
#nav, #content, #footer {
	padding: 8px; 
	border: 1px solid #EEEEEE; 
	clear: both; 
	width: 95%; 
	margin: auto; 
	margin-top: 10px;
}
&#38;lt;/style&#38;gt;
&#38;lt;/head&#38;gt;
&#38;lt;body&#38;gt;

{% with m.site.hostname|default:&#38;quot;localhost&#38;quot; as hostname %}

&#38;lt;h2 style=&#38;quot;text-align: center; margin-top: 20px&#38;quot;&#38;gt;{{ m.config.site.title.value }}&#38;#39;s SiteMap &#38;lt;/h2&#38;gt;
&#38;lt;div id=&#38;quot;nav&#38;quot;&#38;gt;
	&#38;lt;a href=&#38;quot;http://{{ hostname }}&#38;quot;&#38;gt;&#38;lt;strong&#38;gt;{{ m.config.site.title.value }}&#38;lt;/strong&#38;gt;&#38;lt;/a&#38;gt;  &#38;amp;raquo; &#38;lt;a href=&#38;quot;http://{{ hostname }}/sitemap.html&#38;quot;&#38;gt;SiteMap&#38;lt;/a&#38;gt;
&#38;lt;/div&#38;gt;
&#38;lt;div id=&#38;quot;content&#38;quot;&#38;gt;
&#38;lt;h3&#38;gt;文章列表&#38;lt;/h3&#38;gt;
&#38;lt;ul&#38;gt;

	{% for id in result %}
		{% if not m.rsc[id].seo_noindex %}
			{% with m.rsc[id].page_url as page_url %}
				{% ifnotequal page_url &#38;quot;/&#38;quot; %}
	&#38;lt;li&#38;gt;&#38;lt;a href=&#38;quot;http://{{ hostname }}{{ page_url|escapexml }}&#38;quot; title=&#38;quot;{{ m.rsc[id].title }}&#38;quot; target=&#38;quot;_blank&#38;quot;&#38;gt;{{ m.rsc[id].title }}&#38;lt;/a&#38;gt;&#38;lt;/li&#38;gt;
				{% endifnotequal %}
			{% endwith %}
		{% endif %}
	{% endfor %}

&#38;lt;/ul&#38;gt;
&#38;lt;/div&#38;gt;

&#38;lt;center&#38;gt;
&#38;lt;br /&#38;gt;
&#38;lt;br /&#38;gt;
&#38;lt;div style=&#38;quot;text-algin: center; font-size: 11px&#38;quot;&#38;gt;
	&#38;lt;strong&#38;gt;&#38;lt;a href=&#38;quot;http://{{ hostname }}/sitemap.xml&#38;quot; target=&#38;quot;_blank&#38;quot;&#38;gt;SiteMap&#38;lt;/a&#38;gt;&#38;lt;/strong&#38;gt;
&#38;lt;/div&#38;gt;
&#38;lt;br /&#38;gt;
&#38;lt;br /&#38;gt;
&#38;lt;/center&#38;gt;

{% endwith %}
&#38;lt;/body&#38;gt;
&#38;lt;/html&#38;gt;&#60;/pre&#62;&#60;p&#62;sitemap 模板的 html 代码，主要使用了&#60;a title=&#34;zotonic template tag&#34; href=&#34;http://zotonic.com/template-tags&#34; target=&#34;_blank&#34;&#62;zotonic的模板标签(tag)&#60;/a&#62; -- &#60;a title=&#34;zotonic template tag for&#34; href=&#34;http://zotonic.com/docs/latest/ref/tags/tag_for.html&#34; target=&#34;_blank&#34;&#62;for&#60;/a&#62;，把文章数据循环输出来。&#60;/p&#62;&#60;p&#62;该模块可以从 &#60;a title=&#34;github&#34; href=&#34;https://github.com/dhq314/mod_sitemap_html&#34; target=&#34;_blank&#34;&#62;github&#60;/a&#62; 上下载，把模块文件夹放在/priv/sites/网站名/modules(或者&#38;quot;modules/&#38;quot;、&#38;quot;priv/modules&#38;quot;)目录下，打开后台模块页面(System/Modules)激活模块，就可以通过 &#60;a title=&#34;D.H.Q html sitemap&#34; href=&#34;http://dhq.me/sitemap.html&#34;&#62;http://你的域名/sitemap.html&#60;/a&#62; 访问了。&#60;/p&#62;</content>
			
			
			
			
				
			<category term="article" scheme="http://zotonic.com/id/category" />
		</entry>
	


	
		
	
		<entry xmlns="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005" xml:lang="en">
			<id>http://dhq.me/id/361</id>
			<updated>2013-01-19T14:50:11+08:00</updated>
			<published>2013-01-19T14:03:00+08:00</published>
			<author>
				
				<name>Site Administrator</name>
				<uri>http://dhq.me/id/1</uri>
				
			</author>
			
			<link rel="alternate" type="text/html" href="http://dhq.me/zotonic-module-structure"/>
			
			
			
			

			<title>zotonic 的模块结构</title>
			
				<summary>zotonic 的模块是把跟模块功能相关的一些文件或文件夹统一放在一个以模块名命名的文件夹里。以之前介绍过的 mod_syntaxhighlighter 模块为例，它的目录架构如下：从上往下，mod_syntaxhighlighter 是模块的文件夹，模块文件夹下包含有资源文件夹lib、模板文件夹templates和模块的初始信息文件 mod_syntaxhighlighter.erl (跟模块名一样的erl文件)，资源文件夹lib下还包含有css 文件夹和js文件夹。</summary>
				<content type="html">&#60;p&#62;zotonic 的模块是把跟模块功能相关的一些文件或文件夹统一放在一个以模块名命名的文件夹里。以之前&#60;a title=&#34;安装 zotonic 代码语法高亮模块 -- mod_syntaxhighlighter&#34; href=&#34;http://dhq.me/zotonic-install-mod_syntaxhighlighter&#34;&#62;介绍过的 mod_syntaxhighlighter 模块&#60;/a&#62;为例，它的目录架构如下：&#60;/p&#62;&#60;pre class=&#34;brush: text&#34;&#62;|----mod_syntaxhighlighter
| |----lib
| | |----css
| | |----js
| |----templates
| | |----_html_body.tpl
| |----mod_syntaxhighlighter.erl
&#60;/pre&#62;&#60;p&#62;从上往下，mod_syntaxhighlighter 是模块的文件夹，模块文件夹下包含有资源文件夹lib、模板文件夹templates和模块的初始信息文件 mod_syntaxhighlighter.erl (跟模块名一样的erl文件)，资源文件夹lib下还包含有css 文件夹和js文件夹（这两个文件夹里还含有若干css和js文件，由于篇幅省略）。&#60;/p&#62;&#60;p&#62;其实，zotonic 的模块一般由以下文件或文件夹组成：&#60;/p&#62;&#60;p&#62;&#60;strong&#62;模块的初始信息文件&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;这是一个跟模块名一样的erl文件，例如上面的mod_syntaxhighlighter .erl文件。这个文件包含着模块的一些基础信息，例如模块标题、作者、描述、模块权重(priority)等等，这些信息将作为模块的描述信息出现在后台模块管理页面(System/Modules)上。例如mod_syntaxhighlighter .erl内容如下：&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;-module(mod_syntaxhighlighter).

-author(&#38;quot;Alain O&#38;#39;Dea &#38;lt;alain.odea@gmail.com&#38;gt;&#38;quot;).
-mod_title(&#38;quot;SyntaxHighlighter&#38;quot;).
-mod_description(&#38;quot;Alex Gorbatchev&#38;#39;s client-side code highlighter&#38;quot;).
-mod_prio(500).
&#60;/pre&#62;&#60;p&#62;author、mod_title、mod_description分别描述模块作者、标题、摘要等信息。&#60;/p&#62;&#60;p&#62;mod_prio描述的是模块的权重，最高权重是1，默认是500（没有这个属性），具有较高权重的模块是会优先检录，权重一样的话，则根据模块的名称顺序来排（正序）。&#60;/p&#62;&#60;p&#62;如果你想在模块开始运行的时候执行一些操作或初始一些数据，可以导出(export)一个 init/1 的函数，这个init函数的参数Context就是你网站运行时被context记录(record)初始的数据（具体的context初始record值可以查看/include/zotonic.hrl）。如果你想模块被终止的时候执行一些操作，可以导出一个 terminate/2 的函数，第一参数是一个原子，是说明模块被终止的原因，第二个参数跟 init/1 的参数是一样。其实这个跟 erlang 的 &#60;a title=&#34;erlang gen_server&#34; href=&#34;http://www.erlang.org/doc/design_principles/gen_server_concepts.html&#34; target=&#34;_blank&#34;&#62;gen_server&#60;/a&#62; 里的 init 和 terminate 的概念是一样，如果你熟悉 gen_server，这是很容易理解的。当然，你想把模块当作一个进程启动，也可以把这个模块的初始信息文件写成 gen_server的形式，这里不多说具体请看&#60;a title=&#34;zotonic modules base gen_server&#34; href=&#34;http://zotonic.com/docs/latest/manuals/modules/gen_server.html#manual-modules-gen-server&#34; target=&#34;_blank&#34;&#62;这里&#60;/a&#62;。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;actions&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;这个文件夹保存着模块定义的行为。每一个行为文件的名称必须是 “action” 和不包含 &#38;quot;mod_&#38;quot; 的模块名作为前缀，例如在 mod_base 模块里的 dialog_open 行为的文件名是 action_base_dialog_open.erl&#60;/p&#62;&#60;p&#62;&#60;strong&#62;dispatch&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;这个文件夹存放url路由调度规则，定义着每一个被访问的url该做出哪些响应操作，路由规则文件不能是erl的文件类型。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;lib&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;zotonic的资源文件夹，里面存放这一些静态的图片、css和js等文件，这些文件访问的规则由dispatch来定义。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;scomps&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;任何自定义的标签(tag)都放在这个文件夹。自定义标签文件夹里的文件命名跟行为的是一样。例如在 mod_base 模块里的 button 标签的文件名是 scomp_base_button.erl&#60;/p&#62;&#60;p&#62;&#60;strong&#62;controllers&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;这个文件夹包含着定义控制器的erlang模块，这些控制器处理从url路由调度规则传过来的HTTP请求。由于这些控制器是一个erlang模块，所以会被编译并加载到erlang的运行时系统，因此控制器的命名必须是唯一。控制器的命名跟行为的命名规则是一样。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;models&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;这个文件夹存放的是 erlang 模块，每个模块是一个模型。每个模型模块都是以 m_ 开头，例如m_test，并以 m_test 的方式常用在模板文件i。由于模型文件也要编译加载到erlang运行时系统，所以模型文件的命名也要唯一。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;templates&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;存放模板的文件夹&#60;/p&#62;&#60;p&#62;&#60;strong&#62;filters&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;这个文件夹保存的是erlang模块，每一个模块被定义成一个模板过滤器。每一个过滤器必须有一个唯一的名字，映射相对于的过滤器名字，例如，过滤器“tail”写在erlang模块文件filter_tail.erl，该过滤器文件导出一个tail/1的函数。模板编译器将引入正确的过滤器模块到编译模板里，一个错误的过滤器将会导入模板编译失败。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;validators&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;存放一些验证器（例如email格式验证）的文件夹，验证器的命名跟行为的一样，除了前缀是validator之外。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;services&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;这个文件夹也是存在erlang模块文件，每一个服务模块的函数将作为一个API方法，使用这些API，你可以从其他应用程序访问到zotonic，这些都是通过controller_api 调用。服务的命名有一点不同：模块名总是用于服务名称，例如服务 base/export 是放在 mod_base/services/service_base_export.erl 文件里。这个服务可以通过 http://yoursite.com/api/base/export 访问到。&#60;/p&#62;&#60;p&#62;参考：&#60;a title=&#34;Zotonic Mudule Structure&#34; href=&#34;http://zotonic.com/docs/latest/manuals/modules/structure.html&#34; target=&#34;_blank&#34;&#62;Zotonic Module Structure&#60;/a&#62;&#60;/p&#62;</content>
			
			
			
			
				
			<category term="article" scheme="http://zotonic.com/id/category" />
		</entry>
	


	
		
	
		<entry xmlns="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005" xml:lang="en">
			<id>http://dhq.me/id/360</id>
			<updated>2013-01-16T01:36:32+08:00</updated>
			<published>2013-01-15T12:56:00+08:00</published>
			<author>
				
				<name>Site Administrator</name>
				<uri>http://dhq.me/id/1</uri>
				
			</author>
			
			<link rel="alternate" type="text/html" href="http://dhq.me/proxying-zotonic-with-nginx"/>
			
			
			
			

			<title>用 nginx 作为 zotonic 的反向代理</title>
			
				<summary>之前的 zotonic 安装配置时也说过，zotonic 的默认访问端口是8000，就是访问网站的时候要在网站域名后面加上端口值8000，例如本站：http://dhq.me:8000/。这个值由 &quot;/priv/config&quot; 文件里的 listen_port 值决定，如果要改为像平常访问网站那样只填域名不用写上端口值8000访问的话，可以把 listen_port 的值改为80，重启 zotonic 就行。</summary>
				<content type="html">&#60;p&#62;之前的 &#60;a title=&#34;zotonic 安装配置&#34; href=&#34;http://dhq.me/unbuntu-install-zotonic&#34; target=&#34;_self&#34;&#62;zotonic 安装配置&#60;/a&#62;时也说过，zotonic 的默认访问端口是8000，就是访问网站的时候要在网站域名后面加上端口值8000，例如本站：&#60;a title=&#34;D.H.Q&#34; href=&#34;http://dhq.me:8000/&#34; target=&#34;_self&#34;&#62;http://dhq.me:8000/&#60;/a&#62;。这个值由 &#38;quot;/priv/config&#38;quot; 文件里的 listen_port 值决定，如果要改为像平常访问网站那样只填域名不用写上端口值8000访问的话，可以把 listen_port 的值改为80，重启 zotonic 就行（PS：有些系统（例如Mac）使用1024以下端口的话需要管理员权限，不然启动 zotonic 会失败）。&#60;/p&#62;&#60;p&#62;不过，如果你像我在 &#60;a title=&#34;linode&#34; href=&#34;http://www.linode.com/?r=4979bb47b3357142334154628b7d0176b3dff63f&#34; target=&#34;_blank&#34;&#62;linode&#60;/a&#62; 的 VPS 上用 nginx 架设有其他非 zotonic 的网站，那么就需要用 nginx 来作反向代理。还好，官方有一篇介绍用nginx作反向代理的文档 -- 《&#60;a title=&#34;Proxying Zotonic with nginx&#34; href=&#34;http://zotonic.com/docs/latest/manuals/deployment/nginx.html&#34; target=&#34;_blank&#34;&#62;Proxying Zotonic with nginx&#60;/a&#62;》。下面是我用 nginx 配置作反向代理的配置：&#60;/p&#62;&#60;pre class=&#34;brush: text&#34;&#62;server {
  	listen 80;
   	server_name dhq.me www.dhq.me;

    access_log off;

  	keepalive_timeout 65;
  	gzip on;

    location / {
        proxy_pass http://127.0.0.1:8000/;
        proxy_redirect off;

        proxy_set_header   Host             $host;
        proxy_set_header   X-Real-IP        $remote_addr;
        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;

        client_max_body_size       50m;
        client_body_buffer_size    128k;

        proxy_connect_timeout      90;
        proxy_send_timeout         90;
        proxy_read_timeout         90;

        proxy_buffer_size          4k;
        proxy_buffers              4 32k;
        proxy_busy_buffers_size    64k;
        proxy_temp_file_write_size 64k;
    }

    location /close-connection {
        keepalive_timeout 0;
        empty_gif;
    }

}
&#60;/pre&#62;&#60;p&#62;不要忘了把网站配置文件(/priv/sites/网站名/config)里的 hostname 值里的8000去掉，不然网站链接的域名后面还会有8000端口显示出来。&#60;/p&#62;&#60;p&#62;除了以上用 nginx 作反向代理的方法，官方文档上还列举了使用&#60;a title=&#34;authbind&#34; href=&#34;http://en.wikipedia.org/wiki/Authbind&#34; target=&#34;_blank&#34;&#62;authbind&#60;/a&#62;、&#60;a title=&#34;varnish&#34; href=&#34;https://www.varnish-cache.org/&#34; target=&#34;_blank&#34;&#62;Varnish&#60;/a&#62;等方法，这里就不多说了，详细请看&#60;a title=&#34;zotonic deployment&#34; href=&#34;http://zotonic.com/docs/latest/manuals/deployment/index.html&#34; target=&#34;_blank&#34;&#62;这里&#60;/a&#62;。&#60;/p&#62;&#60;p&#62;最后，重启 nginx 反向代理就生效。&#60;/p&#62;</content>
			
			
			
			
				
			<category term="article" scheme="http://zotonic.com/id/category" />
		</entry>
	


	
		
	
		<entry xmlns="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005" xml:lang="en">
			<id>http://dhq.me/id/359</id>
			<updated>2013-01-12T22:12:30+08:00</updated>
			<published>2013-01-12T18:22:00+08:00</published>
			<author>
				
				<name>Site Administrator</name>
				<uri>http://dhq.me/id/1</uri>
				
			</author>
			
			<link rel="alternate" type="text/html" href="http://dhq.me/zotonic-install-mod_syntaxhighlighter"/>
			
			
			
			

			<title>安装 zotonic 代码语法高亮模块 -- mod_syntaxhighlighter</title>
			
				<summary>对于一个对代码有严重洁癖的我来说，一直想给文章里的代码弄个语法高亮显示，起码看代码能看得舒服些吧。还好，在 zotonic模块库 里找到了一个代码高亮的模块 -- mod_syntaxhighlighter（也可以说是zotonic的插件吧）。其实这个模块可以说是现在广为流行使用的语法高亮显示 SyntaxHighlighter 在 zotonic 里的集成，也就是说这个模块是基于 SyntaxHighlighter 做的。</summary>
				<content type="html">&#60;p&#62;对于一个对代码有严重洁癖的我来说，一直想给文章里的代码弄个语法高亮显示，起码看代码能看得舒服些吧。&#60;/p&#62;&#60;p&#62;还好，在 &#60;a title=&#34;zotonic模块库&#34; href=&#34;http://modules.zotonic.com/&#34; target=&#34;_blank&#34;&#62;zotonic模块库&#60;/a&#62; 里找到了一个代码高亮的模块 -- &#60;a title=&#34;mod_syntaxhighlighter&#34; href=&#34;http://modules.zotonic.com/page/352/mod-syntaxhighlighter&#34; target=&#34;_blank&#34;&#62;mod_syntaxhighlighter&#60;/a&#62;（也可以说是zotonic的插件吧）。其实这个模块可以说是现在广为流行使用的语法高亮显示 &#60;a title=&#34;SyntaxHighlighter&#34; href=&#34;http://alexgorbatchev.com/SyntaxHighlighter/&#34; target=&#34;_blank&#34;&#62;SyntaxHighlighter&#60;/a&#62; 在 zotonic 里的集成，也就是说这个模块是基于 SyntaxHighlighter 做的。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;安装 mod_syntaxhighlighter 模块&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;安装zotonic官方模块库里模块很简单，一行命令就能安装（下面命令是在 bin 目录下执行，如果bin目录已经export出来，则可以在终端任何位置执行）：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;zotonic installmodule mod_syntaxhighlighter
&#60;/pre&#62;&#60;p&#62;当然，上面的“一键安装”是有前提的，必须需要 zotonic 版本在7.0版本以上，而且需要系统装有 &#60;a title=&#34;git&#34; href=&#34;http://git-scm.com/&#34; target=&#34;_blank&#34;&#62;git&#60;/a&#62; 或者 &#60;a title=&#34;mercurial&#34; href=&#34;http://mercurial.selenic.com/&#34; target=&#34;_blank&#34;&#62;mercurial&#60;/a&#62; 环境，详细的 &#60;a title=&#34;zotoni模块安装要求&#34; href=&#34;http://modules.zotonic.com/page/326/howto&#34; target=&#34;_blank&#34;&#62;zotonic模块安装要求可以看这里&#60;/a&#62;。&#60;/p&#62;&#60;p&#62;上面的安装方法只适合安装官方模块库里的模块，因为它只默认检索官方模块网站（&#60;a href=&#34;http://modules.zotonic.com/&#34; target=&#34;_blank&#34;&#62;modules.zotonic.com&#60;/a&#62;）上的模块，如果存在，则用 git 或者 mercurial 把模块默认下载到 priv/modules 目录下，并且重新编译模块，刷新模块缓存。&#60;/p&#62;&#60;p&#62;这里，我把 mod_syntaxhighlighter 模块迁移到自己网站目录的模块目录下(/priv/sites/网站名/modules)，为了以后升级zotonic版本好方便管理已安装的模块吧。&#60;/p&#62;&#60;p&#62;PS：其实，zotonic 会默认扫描 &#38;quot;modules/&#38;quot;、&#38;quot;priv/modules&#38;quot;、&#38;quot;/priv/sites/网站名/modules&#38;quot; 这3个目录下的模块，所以，你可以把自己的模块放在这3个目录下的其中之一。&#60;/p&#62;&#60;p&#62;安装完毕后，登陆后台打开到模块页面(&#38;quot;System - Modules&#38;quot;)，找到以 &#38;quot;SyntaxHighlighter&#38;quot; 为名(title)的模块（如果找不到，可以再重新编译make一下，再在状态页面(&#38;quot;system - Status&#38;quot;)点一下&#38;quot;Rescan modules&#38;quot;，重新扫描一下模块），点&#38;quot;Activate&#38;quot;激活它。&#60;/p&#62;&#60;p&#62;这样，mod_syntaxhighlighter 模块就安装好了。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;mod_syntaxhighlighter 使用&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;由于 mod_syntaxhighlighter 是 SyntaxHighlighter 的 zotonic 集成（其实就是重写override了 base.tpl 下的_html_body.tpl, 把SyntaxHighlighter所需要的一些js、css文件加载进来），所以用法跟 SyntaxHighlighter 是一样的，就是把代码放在&#38;lt;pre&#38;gt;标签里，然后给&#38;lt;pre&#38;gt;标签加上一个class属性，标明上是哪种语言代码类型的着色刷子(brush)别名，例如下面erlang代码的写法：&#60;/p&#62;&#60;pre class=&#34;brush: html&#34;&#62;&#38;lt;pre class=&#38;quot;brush: erl&#38;quot;&#38;gt;
    %% Just a test
    io:format(&#38;quot;Just a test.~n&#38;quot;).
&#38;lt;/pre&#38;gt;
&#60;/pre&#62;&#60;p&#62;更多的 SyntaxHighlighter 着色刷子别名可以看&#60;a title=&#34;Syntaxhighlighter Brush Alias&#34; href=&#34;http://alexgorbatchev.com/SyntaxHighlighter/manual/brushes/&#34; target=&#34;_blank&#34;&#62;这里&#60;/a&#62;。&#60;/p&#62;&#60;p&#62;上面添加&#38;lt;pre&#38;gt;标签的方法是要在源代码里编辑，而且还要记住各种语言代码的着色刷子别名，有没有更方便的操作呢？例如可以弹出一个对话框，在对话框里面黏贴代码，然后选择相应的语言代码类型就行了。&#60;/p&#62;&#60;p&#62;答案是肯定的。zotonic 使用 &#60;a title=&#34;TinyMCE&#34; href=&#34;http://www.tinymce.com/&#34; target=&#34;_blank&#34;&#62;TinyMCE&#60;/a&#62; 作为后台所见即所得(WYSIWYG)的文本编辑器，而 &#60;a title=&#34;syntaxhl&#34; href=&#34;https://github.com/RichGuk/syntaxhl&#34; target=&#34;_blank&#34;&#62;SyntaxHL&#60;/a&#62; 则是一个使用 SyntaxHighlighter 来高亮显示代码的 TinyMCE 插件。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;安装 SyntaxHL 插件&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;这里把 SyntaxHL 插件安装在当前网站目录下，所以下面操作的目录起点都是在 &#38;quot;/priv/sites/网站名/&#38;quot; 下。&#60;/p&#62;&#60;p&#62;在网站根目录(/priv/sites/网站名/)下创建 TinyMCE 的插件目录：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;mkdir -p ./lib/js/modules/tinymce3.5.0/plugins
&#60;/pre&#62;&#60;p&#62;上面的&#38;quot;tinymce3.5.0&#38;quot;是指当前 zotonic 使用 TinyMCE 的版本，具体的 TinyMCE 版本可以去目录 /modules/mod_base/lib/js/modules/ 下查看对应的 TinyMCE 文件夹名。&#60;/p&#62;&#60;p&#62;进入刚创建的插件目录，并用 git 下载 SyntaxHL:&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;cd ./lib/js/modules/tinymce3.5.0/plugins
git clone https://github.com/RichGuk/syntaxhl.git 
&#60;/pre&#62;&#60;p&#62;在 templates 目录下创建 SyntaxHL 插件的加载脚本文件：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;vi ./templates/_admin_tinymce_overrides_js.tpl&#60;/pre&#62;&#60;p&#62;在 _admin_tinymce_overrides_js.tpl 里加上以下语句：&#60;/p&#62;&#60;pre class=&#34;brush: js&#34;&#62;tinyInit.plugins += &#38;quot;,syntaxhl&#38;quot;; 
tinyInit.theme_advanced_buttons1 += &#38;quot;,|,syntaxhl&#38;quot;;
&#60;/pre&#62;&#60;p&#62;PS：也可以直接在 /modules/mod_admin/lib/js/modules/tiny-init.js 文件上对 plugins 和 theme_advanced_buttons1 这两个变量进行修改。&#60;/p&#62;&#60;p&#62;OK，刷新一下页面重新进来，就会看到多出一个类似黄色笔头的图标。对！它就是 SyntaxHL 的功能图标，点击进去试用一下吧。&#60;/p&#62;</content>
			
			
			
			
				
			<category term="article" scheme="http://zotonic.com/id/category" />
		</entry>
	


	
		
	
		<entry xmlns="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005" xml:lang="en">
			<id>http://dhq.me/id/357</id>
			<updated>2013-01-14T01:57:53+08:00</updated>
			<published>2013-01-08T20:21:00+08:00</published>
			<author>
				
				<name>Site Administrator</name>
				<uri>http://dhq.me/id/1</uri>
				
			</author>
			
			<link rel="alternate" type="text/html" href="http://dhq.me/zotonic-custom-404"/>
			
			
			
			

			<title>zotonic 自定义类似QQ空间404的公益页面</title>
			
				<summary>最近在微博上看到 QQ空间修改了自己的 404 页面，用户打开了一个网站不存在的页面时，会显示如下图所示的画面。这种把公益融合在功能上的修改，由心的觉得很赞！恰好本人有一个蔽站，何乐而不为呢。</summary>
				<content type="html">&#60;p&#62;最近在微博上看到 QQ空间修改了自己的 &#60;a title=&#34;404定义&#34; href=&#34;http://baike.baidu.com/view/1402912.htm&#34; target=&#34;_blank&#34;&#62;404&#60;/a&#62; 页面，用户打开了一个网站不存在的页面时，会显示如下图所示的画面:&#60;/p&#62;&#60;p&#62;&#60;img title=&#34;QQ空间404&#34; src=&#34;http://app.qpic.cn/mblogpic/c44245be7d79f2e90092/2000&#34; alt=&#34;QQ空间404&#34; /&#62;&#60;/p&#62;&#60;p&#62;这种把公益融合在功能上的修改，由心的觉得很赞！&#60;/p&#62;&#60;p&#62;恰好本人有一个蔽站，这种利人不损自的事情，何乐而不为呢。&#60;/p&#62;&#60;p&#62;对于404的公益数据，国内的 &#60;a title=&#34;益播公益&#34; href=&#34;http://yibo.iyiyun.com/User/install/web404/&#34; target=&#34;_blank&#34;&#62;益播公益&#60;/a&#62; 有提供调用的API，只需在你定义的404页面上加上一下代码就行：&#60;/p&#62;&#60;pre class=&#34;brush: html&#34;&#62;&#38;lt;iframe scrolling=&#38;#39;no&#38;#39; frameborder=&#38;#39;0&#38;#39; src=&#38;#39;http://yibo.iyiyun.com/js/yibo404&#38;#39; width=&#38;#39;735&#38;#39; height=&#38;#39;700&#38;#39; style=&#38;quot;display:block;&#38;quot;&#38;gt;&#38;lt;/iframe&#38;gt;
&#60;/pre&#62;&#60;p&#62;由于 zotonic 把 404 作为系统内部的一个错误，并且把产生的错误默认统一显示在根目录下/modules/mod_base/templates/error.tpl文件下，所以要把上面的代码加在&#38;quot;error.tpl&#38;quot;文件里。不过为了不影响其他网站（如果建有多个 zotonic 网站）的错误显示，或者以后 zotonic 版本升级被覆盖掉，这里我把 error.tpl 文件拷贝一份到我网站的模板目录下(/priv/sites/网站名/templates)。下面“#”里括住的代码是在&#38;quot;error.tpl&#38;quot;文件上新加的对404状态特殊判断的代码。&#60;/p&#62;&#60;pre class=&#34;brush: html&#34;&#62;{% extends &#38;quot;base.tpl&#38;quot; %}

{% block title %} {{ error_code }} Error {% endblock %}

{% block content %}
{% if error_code == 403 %}
	&#38;lt;h1&#38;gt;{_ No Access _}&#38;lt;/h1&#38;gt;
	&#38;lt;p&#38;gt;{_ Sorry, you don’t have access to this page. _}&#38;lt;/p&#38;gt;
	
{################自定义404###############}
{% elseif error_code == 404 %}
	&#38;lt;iframe scrolling=&#38;#39;no&#38;#39; frameborder=&#38;#39;0&#38;#39; src=&#38;#39;http://yibo.iyiyun.com/js/yibo404&#38;#39; width=&#38;#39;735&#38;#39; height=&#38;#39;700&#38;#39; style=&#38;quot;display:block;&#38;quot;&#38;gt;&#38;lt;/iframe&#38;gt;
{########################################}

{% elseif error_code == 410 %}
  &#38;lt;h1&#38;gt;{_ Gone_}&#38;lt;/h1&#38;gt;
  &#38;lt;p&#38;gt;{_ Sorry, this page has been deleted. _}&#38;lt;/p&#38;gt;
{% else %}
...
&#60;/pre&#62;&#60;p&#62;OK，打开 “&#60;a title=&#34;D.H.Q 404&#34; href=&#34;http://dhq.me/404&#34;&#62;http://dhq.me/404&#60;/a&#62;” 或者在域名后面随便输入一些东西看效果吧：）&#60;/p&#62;</content>
			
			
			
			
				
			<category term="article" scheme="http://zotonic.com/id/category" />
		</entry>
	


	
		
	
		<entry xmlns="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005" xml:lang="en">
			<id>http://dhq.me/id/354</id>
			<updated>2013-01-22T11:12:04+08:00</updated>
			<published>2013-01-05T21:17:00+08:00</published>
			<author>
				
				<name>Site Administrator</name>
				<uri>http://dhq.me/id/1</uri>
				
			</author>
			
			<link rel="alternate" type="text/html" href="http://dhq.me/mac-install-nginx-mysql-php-fpm"/>
			
			
			
			

			<title>Mac下nginx、mysql、php-fpm的安装配置</title>
			
				<summary>用了3年多的本本罢工，最近新入手了一台 rmbp，一堆工作环境要配置，LNMP 里的 NMP 是常规要安装的，恰好也是第一次在 mac 上安装配置 nginx、mysql、php，所以顺便做个记录，免得以后忘了也好查看，不用到处翻。</summary>
				<content type="html">&#60;p&#62;用了3年多的本本罢工，最近新入手了一台 rmbp，一堆工作环境要配置，LNMP 里的 NMP 是常规要安装的，恰好也是第一次在 mac 上安装配置 &#60;a title=&#34;nginx官网&#34; href=&#34;http://nginx.org/&#34; target=&#34;_blank&#34;&#62;nginx&#60;/a&#62;、&#60;a title=&#34;mysql官网&#34; href=&#34;http://www.mysql.com/&#34; target=&#34;_blank&#34;&#62;mysql&#60;/a&#62;、&#60;a title=&#34;php官网&#34; href=&#34;http://php.net/&#34; target=&#34;_blank&#34;&#62;php&#60;/a&#62;，所以顺便做个记录，免得以后忘了也好查看，不用到处翻。&#60;/p&#62;&#60;p&#62;PS：下面的安装都是基于 &#60;a title=&#34;homebrew官网&#34; href=&#34;http://mxcl.github.com/homebrew/&#34; target=&#34;_blank&#34;&#62;homebrew&#60;/a&#62;，如果不熟悉或者还没安装有 homebrew 的话，可以查看这篇关于 &#60;a title=&#34;Mac系统下类似于 apt-get 的软件包管理器 -- Homebrew&#34; href=&#34;http://dhq.me/mac-apt-get-homebrew/&#34;&#62;homebrew 的介绍&#60;/a&#62;。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;安装nginx&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;用 brew 一键安装 nignx：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;brew install nginx&#60;/pre&#62;&#60;p&#62;如果需要安装其他 nginx 的版本，可以 &#38;quot;brew edit nginx&#38;quot; 打开修改 nginx 的安装信息包 formula，默认会用 vi 打开，在文件开头处修改 nginx 相应版本的下载地址就行。&#60;/p&#62;&#60;p&#62;brew 执行完后，nginx 就安装好了。可以用以下指令对 nginx 进行操作：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;#打开 nginx
sudo nginx
#重新加载|重启|停止|退出 nginx
nginx -s reload|reopen|stop|quit
&#60;/pre&#62;&#60;p&#62;打开 nginx 后，默认的访问端口 8080，如果要改为常用的 80 端口，则要修改 &#38;quot;/usr/local/etc/nginx/nginx.conf&#38;quot; 下监听(listen)端口值。&#60;/p&#62;&#60;p&#62;默认的文件访问目录(root)是 &#38;quot;/usr/local/Cellar/nginx/1.2.6/html&#38;quot;（这里的1.2.6是安装的nginx的版本，文件夹名以安装的nginx版本为准）。&#60;/p&#62;&#60;p&#62;把 nginx 设置为开机启动运行：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;mkdir -p ~/Library/LaunchAgents
cp /usr/local/Cellar/nginx/1.2.6/homebrew.mxcl.nginx.plist ~/Library/LaunchAgents/
launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist
&#60;/pre&#62;&#60;p&#62;不过试了一下，不是超级用户登陆，而是普通用户登陆，并且监听的端口在1024以下的（例如把默认的8080端口改为了80端口），nginx 开机是启动不了。因此，要 nginx 开机启动的话，需要给予它管理员权限：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;sudo chown root:wheel /usr/local/Cellar/nginx/1.2.6/sbin/nginx
sudo chmod u+s /usr/local/Cellar/nginx/1.2.6/sbin/nginx
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;安装mysql&#60;/strong&#62;&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;brew install mysql&#60;/pre&#62;&#60;p&#62;在上面 brew 安装完后，会在终端上显示一些初始配置 mysql 的信息，如下:&#60;/p&#62;&#60;p&#62;1）初始安装 mysql 的一些配置数据库（例如：information_schema、mysql）&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;mysql_install_db --verbose --user=`whoami` --basedir=&#38;quot;$(brew --prefix mysql)&#38;quot; --datadir=/usr/local/var/mysql --tmpdir=/tmp&#60;/pre&#62;&#60;p&#62;执行完后，就可以在终端里运行 &#38;quot;mysql&#38;quot;，直接进入mysql数据库里。对，不用输入密码，可以直接连接，初始默认是可以匿名访问的。超级用户 &#38;quot;root&#38;quot; 也是没设密码，要设密码的话可以执行下面指令&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;/usr/local/opt/mysql/bin/mysqladmin -u root password &#38;#39;new-password&#38;#39;&#60;/pre&#62;&#60;p&#62;现在访问 mysql 还是不用密码就可以连接，如果要设置一些登陆密码的安全访问限制，则需执行下面的 mysql安全安装指令&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;/usr/local/opt/mysql/bin/mysql_secure_installation&#60;/pre&#62;&#60;p&#62;主要是设置修改root密码（设置过了可以不用设置，略过）、删除匿名访问、删除root网络访问、删除test数据库。指令执行完后，登陆mysql就需要密码验证了&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;mysql -u root -p&#60;/pre&#62;&#60;p&#62;开机启动mysql&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;mkdir -p ~/Library/LaunchAgents/
cp /usr/local/Cellar/mysql/5.5.28/homebrew.mxcl.mysql.plist ~/Library/LaunchAgents/
launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist 
&#60;/pre&#62;&#60;p&#62;至此，mysql安装完毕。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;安装php-fpm&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;Mac是预装了php，不过很多扩展都没安装，目测最多只能在终端里执行下php指令，所以我选择重新安装php。由于 brew 默认是没有 php 安装，所以要使用 “brew tap” 来安装 brew 的第三方程序包，这里使用 josegonzalez 的php安装包，具体操作如下：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;brew tap homebrew/dupes
brew tap josegonzalez/homebrew-php
&#60;/pre&#62;&#60;p&#62;执行完后，就可以用 brew 安装php了。这里php有几个版本可以安装，具体可以执行 &#38;quot;brew search php&#38;quot; 查看一下有什么php版本可以安装，一般会有“php52、php53、php54”版本，我安装的是最新的php5.4版本。由于PHP5.4版本已经内嵌了 FPM，在安装选项里标明就行，我 php 的安装配置指令如下：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;brew install php54 --with-imap --with-tidy --with-debug --with-pgsql --with-mysql --with-fpm
&#60;/pre&#62;&#60;p&#62;更多的安装选项可以通过 &#38;quot;brew options php54&#38;quot; 查看。指令执行完后，php 跟 php-fpm 就安装好了。&#60;/p&#62;&#60;p&#62;由于是重装php，之前系统预装的php还没卸载，因此在终端调用php时，还是以之前系统的php版本做解析，所以这里需要修改path，指定 php 的解析路径。在~/.bashrc（没有则创建）最后加入一行：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;export PATH=&#38;quot;$(brew --prefix php54)/bin:$PATH&#38;quot;
&#60;/pre&#62;&#60;p&#62;添加之后再执行一下source，使之生效&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;source ./.profile&#60;/pre&#62;&#60;p&#62;OK，php-fpm安装完成。&#60;/p&#62;&#60;p&#62;要修改配置 php 或者 php-fpm 的话，可以修改 &#38;quot;/usr/local/etc/php/5.4/php.ini&#38;quot; 、 &#38;quot;/usr/local/etc/php/5.4/php-fpm.conf&#38;quot;。&#60;/p&#62;&#60;p&#62;启动 php-fpm 的话就直接在终端里执行 &#38;quot;php-fpm&#38;quot;(用了一段时间发现启动了&#38;quot;sudo nginx&#38;quot;之后，有调用到php的，php-fpm都会自己启动)，默认打开php-fpm会显示一个状态 shell 出来，也可以把php-fpm的配置文件里的 &#38;quot;daemonize = no&#38;quot; 改为 &#38;quot;daemonize = yes&#38;quot;，就会以后台守护进程的方式启动，对于刚修改的配置文件，可以执行 &#38;quot;php-fpm -t&#38;quot; 来检测配置有没有问题。&#60;/p&#62;&#60;p&#62;打开 nginx 默认注释掉的php location设置，修改如下（具体配置参数，例如路径，这里以我本地安装为准）：&#60;/p&#62;&#60;pre class=&#34;brush: text&#34;&#62;location ~ \.php$ {
    fastcgi_intercept_errors on;
    fastcgi_pass   127.0.0.1:9000;
    fastcgi_index  index.php;
    fastcgi_param  SCRIPT_FILENAME  /usr/local/Cellar/nginx/1.2.6/html$fastcgi_script_name;
    include        /usr/local/etc/nginx/fastcgi_params;
}
&#60;/pre&#62;&#60;p&#62;OK，这样就可以在访问目录下（默认是/usr/local/Cellar/nginx/1.2.6/html）执行 php 文件了。嗯，赶快输出一下 &#38;quot;phpinfo()&#38;quot; 吧：）&#60;/p&#62;</content>
			
			
			
			
				
			<category term="article" scheme="http://zotonic.com/id/category" />
		</entry>
	


	
		
	
		<entry xmlns="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005" xml:lang="en">
			<id>http://dhq.me/id/352</id>
			<updated>2013-02-05T11:23:05+08:00</updated>
			<published>2012-12-31T00:41:00+08:00</published>
			<author>
				
				<name>Site Administrator</name>
				<uri>http://dhq.me/id/1</uri>
				
			</author>
			
			<link rel="alternate" type="text/html" href="http://dhq.me/unbuntu-install-zotonic"/>
			
			
			
			

			<title>zotonic 在 Ubuntu 下的安装配置</title>
			
				<summary>zotonic 是一个用erlang写的、高效、实时的WEB框架，也可以当作一个内容管理系统（CMS）用，据说比一般的PHP CMS要快10倍以上，刚好工作上也用到 erlang，于是就有了把 wordpress 转为 zotonic 的念头。</summary>
				<content type="html">&#60;p&#62;&#60;a title=&#34;zotonic&#34; href=&#34;http://zotonic.com/&#34; target=&#34;_blank&#34;&#62;zotonic&#60;/a&#62; 是一个用erlang写的、高效、实时的WEB框架，也可以当作一个内容管理系统（CMS）用，&#60;a title=&#34;Typically 10 times (and much more) faster than PHP content management systems.&#34; href=&#34;http://zotonic.com/page/614/speed&#34; target=&#34;_blank&#34;&#62;据说比一般的PHP CMS要快10倍以上&#60;/a&#62;，刚好工作上也用到 erlang，于是就有了把 wordpress 转为 zotonic 的念头。&#60;/p&#62;&#60;p&#62;zotonic 由以下开源项目搭建而成：&#60;/p&#62;&#60;ul&#62;&#60;li&#62;&#60;a title=&#34;webmachine&#34; href=&#34;https://github.com/basho/webmachine&#34; target=&#34;_blank&#34;&#62;Webmachine&#60;/a&#62;：一种基于 REST 构建 WEB 应用程序的系统，zotonic 用它来处理 HTTP 协议请求&#60;/li&#62;&#60;li&#62;&#60;a title=&#34;mochiweb&#34; href=&#34;https://github.com/mochi/mochiweb&#34; target=&#34;_blank&#34;&#62;MochiWeb&#60;/a&#62;：一个用来构建轻量高效的HTTP应用程序的 Erlang 库&#60;/li&#62;&#60;li&#62;&#60;a title=&#34;Nitrogen&#34; href=&#34;http://nitrogenproject.com/&#34; target=&#34;_blank&#34;&#62;Nitrogen&#60;/a&#62;：一个构建高效动态网站的 Erlang 框架&#60;/li&#62;&#60;li&#62;&#60;a title=&#34;epgsql&#34; href=&#34;https://github.com/wg/epgsql&#34; target=&#34;_blank&#34;&#62;epgsql&#60;/a&#62;：PostgreSQL 的 Erlang 驱动&#60;/li&#62;&#60;li&#62;&#60;a title=&#34;Twitter Bootstrap&#34; href=&#34;http://twitter.github.com/bootstrap/&#34; target=&#34;_blank&#34;&#62;Bootstrap&#60;/a&#62;：Twitter推出的一个用于前端开发的开源工具包&#60;/li&#62;&#60;li&#62;&#60;a title=&#34;ErlDTL&#34; href=&#34;https://github.com/evanmiller/erlydtl&#34; target=&#34;_blank&#34;&#62;ErlyDTL&#60;/a&#62;：Django 模板语言Erlang的实现&#60;/li&#62;&#60;li&#62;&#60;a title=&#34;jQuery&#34; href=&#34;http://jquery.com/&#34; target=&#34;_blank&#34;&#62;jQuery&#60;/a&#62;：一个快速、简单的 javascript 库&#60;/li&#62;&#60;li&#62;&#60;a title=&#34;gen_smtp&#34; href=&#34;https://github.com/Vagabond/gen_smtp&#34; target=&#34;_blank&#34;&#62;gen_smtp&#60;/a&#62;：一个可以通过回调模块进行扩展的通用的 Erlang SMTP客户端和服务器端&#60;/li&#62;&#60;li&#62;&#60;a title=&#34;erlang-oauth&#34; href=&#34;https://github.com/tim/erlang-oauth&#34; target=&#34;_blank&#34;&#62;erlang-oauth&#60;/a&#62;：Oauth的 Erlang 库&#60;/li&#62;&#60;/ul&#62;&#60;p&#62;由于 zotonic 依赖 &#60;a title=&#34;erlang&#34; href=&#34;http://www.erlang.org/&#34; target=&#34;_blank&#34;&#62;erlang&#60;/a&#62; 的运行环境，需要 &#60;a title=&#34;imagemagick&#34; href=&#34;http://www.imagemagick.org/&#34; target=&#34;_blank&#34;&#62;ImageMagick&#60;/a&#62; 来处理图片，并以 &#60;a title=&#34;postgres&#34; href=&#34;http://www.postgresql.org/&#34; target=&#34;_blank&#34;&#62;postgres&#60;/a&#62; 作为数据库，所以安装zotonic前需要先安装配置好以上东西，&#60;a title=&#34;zotonic installation prerequisites&#34; href=&#34;http://zotonic.com/docs/latest/tutorials/preinstall.html&#34; target=&#34;_blank&#34;&#62;具体安装条件可以查看这里&#60;/a&#62;。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;安装erlang&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;zotonic 需要erlang的版本至少是R14B03。在Ubuntu上安装 erlang 还是比较简单，一条命令就把erlang安装所需的GCC编译环境、Ncurses开发库、OpenSSL开发库、ODBC开发库、Java等依赖包一同安装好：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;sudo apt-get install erlang&#60;/pre&#62;&#60;p&#62;Ubuntu12.10下默认的erlang版本是R15B01，如果需要安装最新的erlang版本，也可以下载最新版本源码安装。&#60;/p&#62;&#60;p&#62;首先安装一些所需的依赖包：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;sudo apt-get install build-essential gcc g++ make libncurses5-dev \
 openssl libssl-dev m4 unixodbc unixodbc-dev freeglut3-dev \ 
 libwxgtk2.8-dev xsltproc fop tk8.5 openjdk-6-jdk openjdk-6-dbg
&#60;/pre&#62;&#60;p&#62;最后下载最新源代码，编译安装：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;wget http://www.erlang.org/download/otp_src_R15B03-1.tar.gz
tar xzf otp_src_R15B03-1.tar.gz
cd otp_src_R15B03-1
./configure
make
sudo make install
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;安装postgresql&#60;/strong&#62;&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;sudo apt-get install postgresql&#60;/pre&#62;&#60;p&#62;安装初始 postgres 数据库&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;sudo su postgres
psql
CREATE USER zotonic WITH PASSWORD &#38;#39;zotonic&#38;#39;;
CREATE DATABASE zotonic WITH OWNER = zotonic ENCODING = &#38;#39;UTF8&#38;#39;;
GRANT ALL ON DATABASE zotonic TO zotonic;
\c zotonic
CREATE LANGUAGE &#38;quot;plpgsql&#38;quot;;
\q
exit
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;安装imagemagick&#60;/strong&#62;&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;sudo apt-get install imagemagick&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;安装 zotonic&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;zotonic 的源代码可以用 git 在 &#60;a title=&#34;zotonic github&#34; href=&#34;https://github.com/zotonic&#34; target=&#34;_blank&#34;&#62;github&#60;/a&#62; 上面下载，&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;git clone git://github.com/zotonic/zotonic.git&#60;/pre&#62;&#60;p&#62;也可以在官方托管的 &#60;a title=&#34;Google Code&#34; href=&#34;http://code.google.com/p/zotonic/&#34; target=&#34;_blank&#34;&#62;google code&#60;/a&#62; 下载，不过上面用 git 下的话默认是最新的开发版本。如果想体验最新的开发功能的话，可以直接用 git 下载。不过说了是最新的开发版，难免会遇到一些安装的问题（本人就刚好中枪，安装了一个开发版，结果页面的 CSS 显示不出来，去用户组反应，得到的反馈是&#60;a title=&#34;zotonic users google group&#34; href=&#34;https://groups.google.com/forum/?fromgroups=#!topic/zotonic-users/ScO81R1uGx0&#34; target=&#34;_blank&#34;&#62;他们昨天已经把这个BUG修复了&#60;/a&#62;...）。&#60;/p&#62;&#60;p&#62;把 zotonic 的源代码下载下来，解压放在一个你想放的目录下，进入zotonic 文件夹的根目录（这里的一些操作命令就不多说了），然后在终端上输入：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;make&#60;/pre&#62;&#60;p&#62;编译 zotonic 的源代码。如果上面所说的安装条件都正确安装，一般都能成功编译。&#60;/p&#62;&#60;p&#62;成功编译完后，就可以启动 zotonic 了。在根目录下有个&#38;quot;start.sh&#38;quot;的文件，运行这个文件的话，就是以 DEBUG 模式启动zotonic（就是显示一个erlang shell），这个跟在bin目录下执行“bin/zotonic debug”是一样，更多的操作命令说明，可以查看&#60;a title=&#34;zotonic cli&#34; href=&#34;http://zotonic.com/docs/latest/manuals/cli.html&#34; target=&#34;_blank&#34;&#62;这里&#60;/a&#62;。&#60;/p&#62;&#60;p&#62;zotonic 运行起来后，可以在浏览器打开 &#38;quot;http://127.0.0.1:8000/&#38;quot;(默认访问端口是8000，由 /priv/config 文件里的 listen_port 值决定)，登陆zotonic的总后台，查看 zotonic 的一些运行状态数据，登陆所需的密码可以在 &#38;quot;priv/config&#38;quot; 文件上的password字段找到，同时，要修改登陆密码的话，修改这个字段就行。&#60;/p&#62;&#60;p&#62;其实，如果是类 &#60;a title=&#34;Debian官网&#34; href=&#34;http://www.debian.org/&#34; target=&#34;_blank&#34;&#62;Debian&#60;/a&#62; 系统（例如Ubuntu）可以直接运行 zotonic 根目录下的 zotonic_install，可以更快更方便的安装配置以上软件包。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;建立第一个zotonic网站&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;进入bin目录，在终端下输入：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;./zotonic addsite -s blog test&#60;/pre&#62;&#60;p&#62;上面的“-s blog”是指网站使用的是blog的架构(skeleton)，“test”就是网站的名字。输入后会出现关于数据库和网站一些参数的确认数据，按回车后网站的初始数据就建立好。&#60;/p&#62;&#60;p&#62;当然，也可以自己指定一些数据库和网站的一些参数，例如：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;./zotonic addsite -s blog -h 127.0.0.1 -p 5432 -u zotonic -P zotonic -d zotonic -n public -a admin test&#60;/pre&#62;&#60;p&#62;参数解释：&#60;/p&#62;&#60;pre class=&#34;brush: text&#34;&#62;&#38;quot;-h&#38;quot;: 指数据库的主机 
&#38;quot;-p&#38;quot;: 指连接数据库的端口
&#38;quot;-u&#38;quot;: 指数据库的用户名
&#38;quot;-P&#38;quot;: 指该用户的密码
&#38;quot;-d&#38;quot;: 指调用的数据库名
&#38;quot;-n&#38;quot;: 指数据库使用的模式(schema)
&#38;quot;-a&#38;quot;: 指网站后台超级用户‘admin’的登陆密码。
&#60;/pre&#62;&#60;p&#62;以上参数都可以在文件“priv/sites/test/config”文件查看或者修改（每创建一个网站，都会在sites目录下创建一个以该网站名命名的文件夹）。更多参数说明可以查看&#60;a title=&#34;zotonic addsite param&#34; href=&#34;http://zotonic.com/docs/latest/manuals/cli.html&#34; target=&#34;_blank&#34;&#62;这里&#60;/a&#62;。&#60;/p&#62;&#60;p&#62;接着修改&#38;quot;/etc/hosts&#38;quot;文件，把网站的名字指定到本机上，在hosts文件添加下面一行：&#60;/p&#62;&#60;pre class=&#34;brush: shell&#34;&#62;127.0.0.1 test&#60;/pre&#62;&#60;p&#62;最后，登陆 zotonic 的总后台(http://127.0.0.1:8000/)，启动刚才建立的网站，在浏览器上输入 “http://test:8000/”，就可以打开查看新建立的网站，也可以打开 “http://test:8000/admin” 登陆网站的管理后台。&#60;/p&#62;&#60;p&#62;OK，zotonic 就在 Ubuntu 下安装配置完:)&#60;/p&#62;</content>
			
			
			
			
				
			<category term="article" scheme="http://zotonic.com/id/category" />
		</entry>
	


	
		
	
		<entry xmlns="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005" xml:lang="en">
			<id>http://dhq.me/id/349</id>
			<updated>2013-01-03T11:09:33+08:00</updated>
			<published>2012-12-25T23:22:00+08:00</published>
			<author>
				
				<name>Site Administrator</name>
				<uri>http://dhq.me/id/1</uri>
				
			</author>
			
			<link rel="alternate" type="text/html" href="http://dhq.me/mac-apt-get-homebrew"/>
			
			
			
			

			<title>Mac系统下类似于 apt-get 的软件包管理器 -- Homebrew</title>
			
				<summary>对于一个习惯了在 Ubuntu 的终端上通过来安装工具软件的我来说，也希望在Mac上找到类似的工具，能很方便的一条命令就能安装所需的软件，而不用手工的去查找下载编译，或者是折腾安装所需的一些依赖关系。很惊喜发现，Mac上也有类似的工具软件包管理器 -- Homebrew</summary>
				<content type="html">&#60;p&#62;对于一个习惯了在 Ubuntu 的终端上通过 apt-get 来安装工具软件的我来说，也希望在Mac上找到类似的工具，能很方便的一条命令就能安装所需的软件，而不用手工的去查找下载编译，或者是折腾安装所需的一些依赖关系。很惊喜发现，Mac上也有类似的工具软件包管理器 -- &#60;a title=&#34;Homebrew&#34; href=&#34;http://mxcl.github.com/homebrew/&#34; target=&#34;_blank&#34;&#62;Homebrew&#60;/a&#62;。&#60;/p&#62;&#60;p&#62;Homebrew 并不是什么软件包都能装，它只是能装一些系统缺省的软件包，例如：wget、nginx、mysql等等。不过随着 &#60;a title=&#34;Homebrew0.9版&#34; href=&#34;https://github.com/mxcl/homebrew/wiki/Homebrew-0.9&#34; target=&#34;_blank&#34;&#62;homebrew0.9版&#60;/a&#62; 新加了 tap 操作，支持安装第三方数据源的软件包，以后支持安装的软件包会更多、更丰富。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;Homebrew安装&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;安装 Homebrew 很简单，只需在终端上输入一行 ruby 脚本（Mac已经预装了ruby语言）就行：&#60;/p&#62;&#60;pre&#62;ruby -e &#38;quot;$(curl -fsSkL raw.github.com/mxcl/homebrew/go)&#38;quot;&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;Homebrew使用&#60;/strong&#62;&#60;/p&#62;&#60;p&#62;Homebrew 跟 Ubuntu 的里的 apt-get 一样，update是更新软件包列表，install是安装软件包，uninstall是卸载软件包，用法都差不多，熟悉 apt-get 使用的话是很容易上手。&#60;/p&#62;&#60;p&#62;下面是 Homebrew 的一些常用操作（package替换成你想安装的软件名，例如：nginx、mysql，就能正常安装你想要安装的软件）：&#60;/p&#62;&#60;p&#62;显示帮助信息&#60;/p&#62;&#60;pre&#62;brew -h&#60;/pre&#62;&#60;p&#62;Homebrew的版本&#60;/p&#62;&#60;pre&#62;brew -v&#60;/pre&#62;&#60;p&#62;列出Homebrew的建议或警告信息&#60;/p&#62;&#60;pre&#62;brew doctor&#60;/pre&#62;&#60;p&#62;列出已安装的软件包&#60;/p&#62;&#60;pre&#62;brew list &#60;/pre&#62;&#60;p&#62;更新Homebrew软件包&#60;/p&#62;&#60;pre&#62;brew update(up)&#60;/pre&#62;&#60;p&#62;用浏览器打开package主页（package为空则打开Homebrew主页）&#60;/p&#62;&#60;pre&#62;brew home package&#60;/pre&#62;&#60;p&#62;显示软件包内容信息&#60;/p&#62;&#60;pre&#62;brew info package&#60;/pre&#62;&#60;p&#62;显示包依赖&#60;/p&#62;&#60;pre&#62;brew deps package&#60;/pre&#62;&#60;p&#62;查找有没有想要安装的软件包（支持模糊查找）&#60;/p&#62;&#60;pre&#62;brew search package&#60;/pre&#62;&#60;p&#62;查看软件包的信息&#60;/p&#62;&#60;pre&#62;brew info package&#60;/pre&#62;&#60;p&#62;软件包的安装选项&#60;/p&#62;&#60;pre&#62;brew options package&#60;/pre&#62;&#60;p&#62;安装软件包&#60;/p&#62;&#60;pre&#62;brew install package&#60;/pre&#62;&#60;p&#62;卸载软件包&#60;/p&#62;&#60;pre&#62;brew uninstall(remove) package &#60;/pre&#62;&#60;p&#62;用 Homebrew 安装第三方工具软件包，例如用 homebrew 安装官方缺省的php&#60;/p&#62;&#60;pre&#62;brew tap josegonzalez/php&#60;/pre&#62;&#60;p&#62;更多详细的用法说明可以在终端输入&#38;quot;man brew&#38;quot;查看。&#60;/p&#62;</content>
			
			
			
			
				
			<category term="article" scheme="http://zotonic.com/id/category" />
		</entry>
	


	
		
	
		<entry xmlns="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005" xml:lang="en">
			<id>http://dhq.me/id/343</id>
			<updated>2013-02-18T20:30:56+08:00</updated>
			<published>2012-12-13T21:50:00+08:00</published>
			<author>
				
				<name>Site Administrator</name>
				<uri>http://dhq.me/id/1</uri>
				
			</author>
			
			<link rel="alternate" type="text/html" href="http://dhq.me/erlang-dict-intro"/>
			
			
			
			

			<title>erlang的dict模块函数方法介绍</title>
			
				<summary>erlang 的 dict 模块比较完整的实现了一个键值(Key - Value)字典。通过这个模块，你可以插入，附加(append)，删除，更新键值对字典，也提供了获取字典大小和检查键是否存在等调用接口，而且还包含一些对字典键或值进行操作的函数方法，例如：递归(fold)、过滤(filter)、遍历(map)字典等特殊操作函数</summary>
				<content type="html">&#60;p&#62;erlang 的 &#60;a title=&#34;dict官方介绍&#34; href=&#34;http://www.erlang.org/doc/man/dict.html&#34; target=&#34;_blank&#34;&#62;dict&#60;/a&#62; 模块比较完整的实现了一个键值(Key - Value)字典。通过这个模块，你可以插入，附加(append)，删除，更新键值对字典，也提供了获取字典大小和检查键是否存在等调用接口，而且还包含一些对字典键或值进行操作的函数方法，例如：递归(fold)、过滤(filter)、遍历(map)字典等特殊操作函数。&#60;/p&#62;&#60;p&#62;&#60;strong&#62;new() -&#38;gt; dictionary()&#60;/strong&#62;：生成一个新的原始字典（其实是返回一个内部定义的dict记录record）&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;dict:new().
%% 下面是返回的dict记录的初始值，具体请看\lib\stdlib-1.18.2\src\dict.erl
-record(dict, {
	size=0		      	:: non_neg_integer(),   	% Number of elements
	n=?seg_size	      	:: non_neg_integer(),   	% Number of active slots
	maxn=?seg_size	   	:: non_neg_integer(),		% Maximum slots
	bso=?seg_size div 2	:: non_neg_integer(),   	% Buddy slot offset
	exp_size=?exp_size 	:: non_neg_integer(),   	% Size to expand at
	con_size=?con_size 	:: non_neg_integer(),   	% Size to contract at
	empty		      	:: tuple(),					% Empty segment
	segs		      	:: tuple()	      			% Segments
}).
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;store(Key, Value, Dict1) -&#38;gt; Dict2&#60;/strong&#62;：以键值对的形式(Key - Value)存储在字典里。如果字典里已经存在Key的键，则Key相关的值替换为Value&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;D = dict:new(),
D1 = dict:store(k1, v1, D).
%% D2 = dict:store(k2, v2, D1).
%% D3 = dict:store(k2, v3, D2).
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;from_list(List) -&#38;gt; Dict&#60;/strong&#62;：把一个key-value形式的列表转换为一个字典&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;dict:from_list([{k1, v1}, {k2, v2}, {k3, v3}]).
%% 相当于
D = dict:new(),
D1 = dict:store(k1, v1, D),
D2 = dict:store(k2, v2, D1),
D3 = dict:store(k3, v3, D2).
&#60;/pre&#62;&#60;!--more--&#62;&#60;p&#62;&#60;strong&#62;size(Dict) -&#38;gt; int()&#60;/strong&#62;：返回字典元素的数量&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;dict:size(dict:from_list([{k1, v1}, {k2, v2}, {k3, v3}])).
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;to_list(Dict) -&#38;gt; List&#60;/strong&#62;：把字典转换成一个列表形式&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;D = dict:from_list([{k1, v1}, {k2, v2}, {k3, v3}]).
dict:to_list(D).
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;append(Key, Value, Dict1) -&#38;gt; Dict2&#60;/strong&#62;：给与键相关联的值的当前列表添加一个新值&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;D = dict:new().
D1 = dict:append(a, b, D).
dict:to_list(D1).
D2 = dict:append(a, c, D1).
dict:to_list(D2).
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;append_list(Key, ValList, Dict1) -&#38;gt; Dict2&#60;/strong&#62;：给与键相关联的值的当前列表添加一个列表值&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;D = dict:new(),
D1 = dict:store(k, [v1], D),
D2 = dict:append_list(k, [v2, v3], D1),
dict:to_list(D2).
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;erase(Key, Dict1) -&#38;gt; Dict2&#60;/strong&#62;：清除字典里与键相关联的所有项&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;D = dict:from_list([{k1, v1}, {k2, v2}, {k3, v3}]).
dict:to_list(D).
dict:to_list(dict:erase(k1, D)).
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;is_key(Key, Dict) -&#38;gt; bool()&#60;/strong&#62;：指定的键(Key)是否在字典里&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;D = dict:from_list([{k1, v1}, {k2, v2}, {k3, v3}]),
dict:is_key(k1, D).
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;fetch(Key, Dict) -&#38;gt; Value&#60;/strong&#62;：返回一个在字典里跟键相关联的值（如果在字典里没有相关联的值则报错）&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;D = dict:from_list([{k1, v1}, {k2, v2}, {k3, v3}]).
dict:fetch(k1, D).
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;fetch_keys(Dict) -&#38;gt; Keys&#60;/strong&#62;：以列表的形式返回字典里所有的键&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;D = dict:from_list([{k1, v1}, {k2, v2}, {k3, v3}]).
dict:fetch_keys(D).
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;filter(Pred, Dict1) -&#38;gt; Dict2&#60;/strong&#62;：返回符合筛选过滤函数(Pred)条件的所有键和值的字典&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;D = dict:from_list([{k1, v1}, {k2, v2}, {k3, v3}]),
D1 = dict:filter(fun(_K, V)-&#38;gt; V == v2 end, D),
dict:to_list(D1).
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;find(Key, Dict) -&#38;gt; {ok, Value} | error&#60;/strong&#62;：跟fetch一样，都是查找返回一个在字典里跟键相关联的值，不过返回的格式不一样，而且字典里没有相关联的值不会，只返回一个原子error&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;D = dict:from_list([{k1, v1}, {k2, v2}, {k3, v3}]),
dict:find(k1, D).
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;fold(Fun, Acc0, Dict) -&#38;gt; Acc1&#60;/strong&#62;：对字典里的每一个键(Key)或值(Value)跟一个临时累积参数一齐遍历调用函数(Fun)，并返回一个新的累积器（accumulator）以传给下一次函数(Fun)调用&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;%% 这里是求字典里所有值得平方和
D = dict:from_list([{k1, 1}, {k2, 2}, {k3, 3}]),
dict:fold(fun(_Key,Val, Acc) -&#38;gt; Val * Val + Acc end, 0, D).
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;map(Fun, Dict1) -&#38;gt; Dict2&#60;/strong&#62;：对字典里的每一个键(Key)或值(Value)遍历调用函数(Fun)并返回一个新的字典&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;D = dict:from_list([{k1, 1}, {k2, 2}, {k3, 3}]),
dict:map(fun(_Key, Val) -&#38;gt; Val * Val end, D).
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;merge(Fun, Dict1, Dict2) -&#38;gt; Dict3&#60;/strong&#62;：把2个字典合并成为一个新的字典，原来字典的键值都有保留，如果存在相同的键，则调用函数Fun处理返回一个新值&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;L1 = [{k1, 1}, {k2, 2}, {k3, 3}],
L2 = [{k1, 1}, {k2, 2}, {k3, 3}, {k4, 4}],
%% 这里如果有键相同时，则把值相加
MergeFun = fun(_Key, V1, V2) -&#38;gt; V1 + V2 end,
D1 = dict:from_list(L1),
D2 = dict:from_list(L2),
dict:to_list(dict:merge(MergeFun, D1, D2)).
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;update(Key, Fun, Dict1) -&#38;gt; Dict2&#60;/strong&#62;：通过调用一个函数(Fun)来更新跟给出的键相关的值，如果指定的键在字典里不存在则报错&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;D = dict:from_list([{k1, 1}, {k2, 2}]),
dict:to_list(D),
D1 = dict:update(k1, fun(V)-&#38;gt; V * 2 end, D),
dict:to_list(D1).
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;update(Key, Fun, Initial, Dict1) -&#38;gt; Dict2&#60;/strong&#62;：跟上面update一样，都是通过调用一个函数(Fun)来更新跟给出的键相关的值，不过如果指定的键在字典里不存在，则用给出的指定初始值（Initial）替换&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;D = dict:from_list([{k1, 1}, {k2, 2}]),
dict:to_list(D),
D1 = dict:update(k3, fun(V)-&#38;gt; V * 2 end, 3, D),
dict:to_list(D1).
&#60;/pre&#62;&#60;p&#62;&#60;strong&#62;update_counter(Key, Increment, Dict1) -&#38;gt; Dict2&#60;/strong&#62;：对跟给出的键相关的值进行累加(Increment)，如果字典里没有给出的相关的键，则用累加的值替换&#60;/p&#62;&#60;pre class=&#34;brush: erl&#34;&#62;D = dict:from_list([{k,1}]),
D1 = dict:update_counter(k, 1, D),
dict:to_list(D1).
%% 字典不存在键值则新加
D1 = dict:update_counter(k1, 1, D),
dict:to_list(D1).
&#60;/pre&#62;</content>
			
			
			
			
				
			<category term="article" scheme="http://zotonic.com/id/category" />
		</entry>
	


	
		
	
		<entry xmlns="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005" xml:lang="en">
			<id>http://dhq.me/id/340</id>
			<updated>2012-12-14T21:58:09+08:00</updated>
			<published>2012-12-13T21:39:00+08:00</published>
			<author>
				
				<name>Site Administrator</name>
				<uri>http://dhq.me/id/1</uri>
				
			</author>
			
			<link rel="alternate" type="text/html" href="http://dhq.me/linux-sed-usage"/>
			
			
			
			

			<title>linux命令学习 -- sed</title>
			
				<summary>sed(streams editor)其实是一个文件处理的编辑器，具有对文件数据进行新增、替换、删除、打印、取代特定行数据等功能。它本身是一个管道命令，操作文件数据时，先把文件数据的每一行数据放在一个临时的缓冲区，然后再执行指定的操作，最后处理完再把数据显示输出。如果没有指定直接修改的选项，sed是不会改变文件的数据</summary>
				<content type="html">&#60;p&#62;&#60;a title=&#34;sed的GNU主页&#34; href=&#34;http://www.gnu.org/software/sed/&#34; target=&#34;_blank&#34;&#62;sed&#60;/a&#62;(streams editor)其实是一个文件处理的编辑器，具有对文件数据进行新增、替换、删除、打印、取代特定行数据等功能。它本身是一个管道命令，操作文件数据时，先把文件数据的每一行数据放在一个临时的缓冲区，然后再执行指定的操作，最后处理完再把数据显示输出。如果没有指定直接修改的选项，sed是不会改变文件的数据。&#60;/p&#62;&#60;p&#62;sed的命令格式：&#60;/p&#62;&#60;pre&#62;sed [选项] &#38;#39;操作命令&#38;#39; 要被操作的文件
&#60;/pre&#62;&#60;p&#62;例如有一个test.txt的文件，内容如下：&#60;/p&#62;&#60;pre&#62;a
b
c
d
e
$
abcdefghijklmnopqrstuvwxyz
&#60;/pre&#62;&#60;p&#62;想删除文件里的第2和第3行，可以这样写sed：&#60;/p&#62;&#60;pre&#62;sed -e &#38;#39;2,3d&#38;#39; ./test.txt
&#60;/pre&#62;&#60;p&#62;可以看到，文件text.txt原来第2和第3行的数据&#38;quot;b&#38;quot;、&#38;quot;c&#38;quot;是不会显示出来。上面“-e”是选项，“&#38;#39;2,3d&#38;#39;”是操作命令（命令要以两个引号&#38;#39;&#38;#39;括住），“./test.txt”是要被操作的文件。&#60;/p&#62;&#60;p&#62;常用的sed选项:&#60;/p&#62;&#60;pre&#62;-n: （或--quiet或--silent）安静(silent)模式，只显示操作命令处理后的数据，例如要显示第2和第3行数据，可以对比查看“sed -n &#38;#39;2,3p&#38;#39; ./test.txt”跟“sed &#38;#39;2,3p&#38;#39; ./test.txt”的输出区别
-e: 后跟操作命令（script），表示以指定的操作命令来处理输入的文件数据,例如上面的：sed -e &#38;#39;2,3d&#38;#39; ./test.txt
-f: 把sed的操作命令写在一个文件里， 例如：sed [选项] -f scriptfile filename，-f scriptfile则可以执行scriptfile内的sed操作命令
-r: sed的动作支援的是延伸型正则表达式的语法。(预设是基础正则表达式语法)
-i: 直接修改读取的文件数据，而不是在屏幕上输出
-h: （或--help）显示帮助
-V: （或--version）显示版本信息
&#60;/pre&#62;&#60;p&#62;更多的sed选项信息可以&#38;quot;sed -h&#38;quot;输出查看。&#60;/p&#62;&#60;!--more--&#62;&#60;p&#62;常用的sed操作命令:&#60;/p&#62;&#60;pre&#62;a: 新增，a 的后面接要添加的字串，新增在指定行的下一行，例如在第2行后面添加一行“test”：&#38;#39;2a test&#38;#39;
i: 插入，i 的后面接要添加的字串，新增在指定行的上一行，例如在第2行前面添加一行“test”：&#38;#39;2i test&#38;#39;
c: 替换，c 的后面接要替换的字串，这些字串可以替换 n1,n2 之间的行，例如将第2、3行内容替换为&#38;quot;bc&#38;quot;：&#38;#39;2,3c bc&#38;#39;
d: 删除，例如删除第2、3行数据&#38;#39;2,3d&#38;#39;（d不接任何字串）
p: 打印，把操作命令处理过数据打印出来，通常 p 会与参数 sed -n 一起调用，例如显示第2、3行数据：&#38;#39;2,3p&#38;#39;
s: 取代，&#38;#39;s/要被取代的字串(这里可以是正则表达式)/新的字串/g&#38;#39;，例如把b换成aa：&#38;#39;s/b/aa/g&#38;#39;
&#60;/pre&#62;&#60;p&#62;常用的一些例子：&#60;/p&#62;&#60;p&#62;新增：&#60;/p&#62;&#60;pre&#62;sed &#38;#39;2a just a test&#38;#39; ./test.txt        #第2行后添加字符串&#38;quot;just a test&#38;quot;
sed &#38;#39;2i just a test&#38;#39; ./test.txt        #第2行前添加字符串&#38;quot;just a test&#38;quot;
sed &#38;#39;1,3a just a test&#38;#39; ./test.txt      #第1行到第3行后增加字符串&#38;quot;just a test&#38;quot;
sed &#38;#39;2a 1row\n2row&#38;#39; ./test.txt         #第2行后增加多行，这里“\n”是换行符
&#60;/pre&#62;&#60;p&#62;替换：&#60;/p&#62;&#60;pre&#62;sed &#38;#39;2c bbb&#38;#39; ./test.txt         #第2行替换为&#38;quot;bbb&#38;quot;
sed &#38;#39;2,4c bcd&#38;#39; ./test.txt       #第2行到第4行替换为&#38;quot;bcd&#38;quot;
&#60;/pre&#62;&#60;p&#62;删除：&#60;/p&#62;&#60;pre&#62;sed &#38;#39;1d&#38;#39; ./test.txt             #删除第1行
sed &#38;#39;2d&#38;#39; ./test.txt             #删除第2行
sed &#38;#39;$d&#38;#39; ./test.txt             #删除最后1行（$表示最后1行）
sed &#38;#39;2,3d&#38;#39; ./test.txt           #删除第2行到第3行
nl ./test.txt | sed &#38;#39;2,3d&#38;#39;      #删除第2行到第3行（显示行号）
sed &#38;#39;2,$d&#38;#39; ./test.txt           #删除第2行到最后1行
&#60;/pre&#62;&#60;p&#62;打印：&#60;/p&#62;&#60;pre&#62;sed -n &#38;#39;1p&#38;#39; ./test.txt           #显示第1行
sed -n &#38;#39;$p&#38;#39; ./test.txt           #显示最后1行
sed -n &#38;#39;2,3p&#38;#39; ./test.txt         #显示第2行到第3行
sed -n &#38;#39;2,$p&#38;#39; ./test.txt         #显示第2行到最后1行
sed -n &#38;#39;/a/p&#38;#39; ./test.txt         #查找包含关键字a所在所有行
sed -n &#38;#39;/\$/p&#38;#39; ./test.txt        #查找包含关键字$所在所有行，这里反斜线&#38;quot;\&#38;quot;是转义，屏蔽特殊符号
&#60;/pre&#62;&#60;p&#62;取代:&#60;/p&#62;&#60;pre&#62;sed &#38;#39;s/b/bbbbbbbbbb/g&#38;#39; ./test.txt    #把b取代为bbbbbbbbbb
sed &#38;#39;s/b//g&#38;#39; ./test.txt              #删除b
sed &#38;#39;s/^.*efg//g&#38;#39; ./test.txt         #把abcdefg之前删掉，这里的^表示开头，&#38;quot;.*&#38;quot;表示匹配任意字串
sed &#38;#39;s/efg.*$//g&#38;#39; ./test.txt         #把abcd之后的删掉
&#60;/pre&#62;&#60;p&#62;使用选项&#38;quot;i&#38;quot;直接修改文件：&#60;/p&#62;&#60;pre&#62;sed -i &#38;#39;s/c/ccccccc/g&#38;#39; ./test.txt    #把c替换为ccccccc
sed -i &#38;#39;$a end&#38;#39; ./test.txt           #在文件最后1行直接插入&#38;quot;end&#38;quot;
&#60;/pre&#62;</content>
			
			
			
			
				
			<category term="article" scheme="http://zotonic.com/id/category" />
		</entry>
	


	
		
	
		<entry xmlns="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005" xml:lang="en">
			<id>http://dhq.me/id/338</id>
			<updated>2013-01-08T10:34:07+08:00</updated>
			<published>2012-12-12T21:51:00+08:00</published>
			<author>
				
				<name>Site Administrator</name>
				<uri>http://dhq.me/id/1</uri>
				
			</author>
			
			<link rel="alternate" type="text/html" href="http://dhq.me/ubuntu-install-use-memcache"/>
			
			
			
			

			<title>Ubuntu 12.04 LTS下memcache的安装使用</title>
			
				<summary>Memcache 是一个免费、开源、高性能的分布式内存对象缓存系统。它把WEB应用程序所需的数据以Key-Value的形式存储在内存中，提高了WEB应用程序数据的读取速度，减轻了数据库的负载，从而加速动态WEB应用程序的响应速度</summary>
				<content type="html">&#60;p&#62;&#60;a title=&#34;Memcache&#34; href=&#34;http://memcached.org/&#34; target=&#34;_blank&#34;&#62;Memcache &#60;/a&#62;是一个免费、开源、高性能的分布式内存对象缓存系统。它把WEB应用程序所需的数据以Key-Value的形式存储在内存中，提高了WEB应用程序数据的读取速度，减轻了数据库的负载，从而加速动态WEB应用程序的响应速度。&#60;/p&#62;&#60;p&#62;安装memcached服务端:&#60;/p&#62;&#60;pre&#62;apt-get install memcached&#60;/pre&#62;&#60;p&#62;启动memcache:&#60;/p&#62;&#60;pre&#62;memcached -d -m 50 -p 11211 -u memcache -l 127.0.0.1&#60;/pre&#62;&#60;p&#62;关闭memcache:&#60;/p&#62;&#60;pre&#62;kill -9 memcache的进程ID&#60;/pre&#62;&#60;p&#62;常用memcache启动参数介绍:&#60;/p&#62;&#60;pre&#62;-d：以daemon的方式在后台启动运行一个守护进程
-m：分配给Memcache使用的最大内存数量，单位是MB，默认是64MB
-u：设定运行Memcache的用户（memcache默认不允许以root用户登录）
-l：监听的服务器IP地址
-p：设置Memcache监听的TCP端口，默认是11211(p为小写)
-c：设置最大并发连接数，默认是1024
-P：设置保存Memcache的pid文件路径(P为大写)
-h：显示帮助
&#60;/pre&#62;&#60;p&#62;安装完毕后，可以用这个命令来检测memcache是否正常启动，如果看到如上启动memcache的指令，则安装成功：&#60;/p&#62;&#60;pre&#62;ps aux | grep memcache&#60;/pre&#62;&#60;p&#62;安装PHP Memecache 客户端:&#60;/p&#62;&#60;pre&#62;apt-get install php5-memcache&#60;/pre&#62;&#60;p&#62;执行完后重启nginx和fastcgi服务，phpinfo()输出能看见memcache扩展，则PHP Memcache客户端安装成功。&#60;/p&#62;&#60;p&#62;修改PHP配置文件php.ini，用memcache存储session会话，加快数据之间处理速度：&#60;/p&#62;&#60;pre&#62;session.save_handler = memcache
session.save_path = &#38;quot;tcp://127.0.0.1:11211&#38;quot;
&#60;/pre&#62;&#60;p&#62;也可以修改 .htaccess 文件：&#60;/p&#62;&#60;pre&#62;php_value session.save_handler &#38;quot;memcache&#38;quot;
php_value session.save_path &#38;quot;tcp://127.0.0.1:11211&#38;quot;
&#60;/pre&#62;&#60;p&#62;或者在某个应用中初始设置：&#60;/p&#62;&#60;pre&#62;ini_set(&#38;quot;session.save_handler&#38;quot;, &#38;quot;memcache&#38;quot;);
ini_set(&#38;quot;session.save_path&#38;quot;, &#38;quot;tcp://127.0.0.1:11211&#38;quot;);
&#60;/pre&#62;&#60;p&#62;使用多个 Memcached Server 时要用逗号&#38;quot;,&#38;quot;隔开，并且可以带额外的参数&#38;quot;persistent&#38;quot;、&#38;quot;weight&#38;quot;、&#38;quot;timeout&#38;quot;、&#38;quot;retry_interval&#38;quot; 等，例如：&#60;/p&#62;&#60;pre&#62;tcp://host1:port1?persistent=1&#38;amp;weight=2,tcp://host2:port2
&#60;/pre&#62;&#60;p&#62;一个简单的php memcahche使用例子：&#60;/p&#62;&#60;pre&#62;//创建Memcache对象
$mem = new Memcache();
//连接Memcache服务器
$mem-&#38;gt;connect(&#38;#39;127.0.0.1&#38;#39;, 11211);
$val = &#38;#39;This is a memcache test!&#38;#39;;
$key = md5($val);
//判断是否获取到指定key的数据，没缓存则增加一条过期时间为300秒的数据
if ( $data = $mem-&#38;gt;get($key) )
{
    echo &#38;#39;from cache data: &#38;#39; . $data;
}
else
{
    $mem-&#38;gt;set($key, $val, 0, 300);
    echo &#38;#39;new set data: &#38;#39; . $val;
}
&#60;/pre&#62;&#60;p&#62;更多的使用介绍可以查看&#60;a title=&#34;PHP官方的memecache文档&#34; href=&#34;http://cn2.php.net/memcache&#34; target=&#34;_blank&#34;&#62;PHP官方的memecache文档&#60;/a&#62;&#60;/p&#62;</content>
			
			
			
			
				
			<category term="article" scheme="http://zotonic.com/id/category" />
		</entry>
	


	
		
	
		<entry xmlns="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005" xml:lang="en">
			<id>http://dhq.me/id/335</id>
			<updated>2012-12-13T21:19:28+08:00</updated>
			<published>2012-12-12T21:41:00+08:00</published>
			<author>
				
				<name>Site Administrator</name>
				<uri>http://dhq.me/id/1</uri>
				
			</author>
			
			<link rel="alternate" type="text/html" href="http://dhq.me/ubuntu-spawn-fcgi-to-php-fpm"/>
			
			
			
			

			<title>Ubuntu下spawn-fcgi迁移到php-fpm</title>
			
				<summary>这几天发现我512M内存的 linode，内存一直占用400多M，不过CPU不高，在网上找了下原因，说spawn-fcgi有内存泄露的缺陷。当前服务器的配置是按照 Linode Library 配置的nginx+spawn-fcgi+php-cgi方式，很怀疑是不是内存泄露的问题。512M内存的伤不起啊，于是决定把php的通信接口由spawn-fcgi改为php-fpm，况且php-fpm是专门为php而设计，可以说是最理想不过的php通信接口</summary>
				<content type="html">&#60;p&#62;这几天发现我512M内存的 &#60;a title=&#34;linode&#34; href=&#34;http://www.linode.com/?r=4979bb47b3357142334154628b7d0176b3dff63f&#34; target=&#34;_blank&#34;&#62;linode&#60;/a&#62;，内存一直占用400多M，不过CPU不高，在网上找了下原因，说&#60;a title=&#34;spawn-fcgi内存泄露缺陷&#34; href=&#34;http://blog.csdn.net/omohe/article/details/4336731&#34; target=&#34;_blank&#34;&#62;spawn-fcgi有内存泄露的缺陷&#60;/a&#62;。当前服务器的配置是按照 &#60;a title=&#34;Linode Library&#34; href=&#34;http://library.linode.com/lemp-guides/ubuntu-12.04-precise-pangolin&#34; target=&#34;_blank&#34;&#62;Linode Library&#60;/a&#62; 配置的nginx+spawn-fcgi+php-cgi方式，很怀疑是不是内存泄露的问题。512M内存的伤不起啊，于是决定把php的通信接口由spawn-fcgi改为php-fpm，况且php-fpm是专门为php而设计，可以说是最理想不过的php通信接口。&#60;/p&#62;&#60;p&#62;php-fpm是什么？&#60;a title=&#34;php-fpm官网&#34; href=&#34;http://php-fpm.org/&#34; target=&#34;_blank&#34;&#62;php-fpm&#60;/a&#62;（FastCGI Process Manager）是一个简单、功能强大，专门服务于php的FastCGI进程管理器。&#60;/p&#62;&#60;p&#62;当前我用的是Ubuntu 12.04 LTS，安装php-fpm很简单：&#60;/p&#62;&#60;pre&#62;apt-get install php5-fpm&#60;/pre&#62;&#60;p&#62;由于之前安装过spawn-fcgi，所以使用php-fpm的话，还需要先把spawn-fcgi先关掉卸载：&#60;/p&#62;&#60;pre&#62;#关闭fastcgi进程
killall -HUP php5-cgi
#卸载spawn-fcgi
apt-get remove spawn-fcgi
&#60;/pre&#62;&#60;p&#62;去掉spawn-fcgi开机启动：&#60;/p&#62;&#60;pre&#62;/usr/sbin/update-rc.d -f php-fastcgi remove&#60;/pre&#62;&#60;p&#62;接着就可以开启（关闭、重启）php-fpm：&#60;/p&#62;&#60;pre&#62;/etc/init.d/php5-fpm start | stop | restart
&#60;/pre&#62;&#60;p&#62;如果想php-fpm开机启动，可以执行者命令：&#60;/p&#62;&#60;pre&#62;/usr/sbin/update-rc.d php5-fpm defaults
&#60;/pre&#62;&#60;p&#62;PS：发现安装完php-fpm后，php的配置文件（php.ini）的文件位置居然改变了（变为/etc/php5/fpm/php.ini，具体改变的位置可以输出phpinfo()查看），所以之前配置的一些参数也要改过来，例如之前我配的 &#60;a title=&#34;Ubuntu 12.04 LTS下安装eAccelerator&#34; href=&#34;http://dhq.me/ubuntu-install-eaccelerator/&#34;&#62;eAccelerator&#60;/a&#62;，新的php.ini是没有的，还需自己改过来...&#60;/p&#62;&#60;p&#62;最后附上一篇来上&#60;a title=&#34;php-fpm配置详解&#34; href=&#34;http://blog.hexu.org/archives/1078.shtml&#34; target=&#34;_blank&#34;&#62;网上&#60;/a&#62;关于 php-fpm配置（配置默认放在/etc/php5/fpm/php-fpm.conf）的说明，说得很详细：&#60;/p&#62;&#60;pre&#62;pid = run/php-fpm.pid
#pid设置，默认在安装目录中的var/run/php-fpm.pid，建议开启

error_log = log/php-fpm.log
#错误日志，默认在安装目录中的var/log/php-fpm.log

log_level = notice
#错误级别. 可用级别为: alert（必须立即处理）, error（错误情况）, warning（警告情况）, notice（一般重要信息）, debug（调试信息）. 默认: notice.

emergency_restart_threshold = 60
emergency_restart_interval = 60s
#表示在emergency_restart_interval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过 emergency_restart_threshold个，php-fpm就会优雅重启。这两个选项一般保持默认值。

process_control_timeout = 0
#设置子进程接受主进程复用信号的超时时间. 可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒). 默认值: 0.

daemonize = yes
#后台执行fpm,默认值为yes，如果为了调试可以改为no。在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置。

listen = 127.0.0.1:9000
#fpm监听端口，即nginx中php处理的地址，一般默认值即可。可用格式为: ‘ip:port’, ‘port’, ‘/path/to/unix/socket’. 每个进程池都需要设置.

listen.backlog = -1
#backlog数，-1表示无限制，由操作系统决定，此行注释掉就行。backlog含义参考：http://www.3gyou.cc/?p=41

listen.allowed_clients = 127.0.0.1
#允许访问FastCGI进程的IP，设置any为不限制IP，如果要设置其他主机的nginx也能访问这台FPM进程，listen处要设置成本地可被访问的IP。默认值是any。每个地址是用逗号分隔. 如果没有设置或者为空，则允许任何服务器请求连接

listen.owner = www
listen.group = www
listen.mode = 0666
#unix socket设置选项，如果使用tcp方式访问，这里注释即可。

user = www
group = www
#启动进程的帐户和组

pm = dynamic #对于专用服务器，pm可以设置为static。
#如何控制子进程，选项有static和dynamic。如果选择static，则由pm.max_children指定固定的子进程数。如果选择dynamic，则由下开参数决定：
pm.max_children #，子进程最大数
pm.start_servers #，启动时的进程数
pm.min_spare_servers #，保证空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程
pm.max_spare_servers #，保证空闲进程数最大值，如果空闲进程大于此值，此进行清理

pm.max_requests = 1000
#设置每个子进程重生之前服务的请求数. 对于可能存在内存泄漏的第三方模块来说是非常有用的. 如果设置为 ’0′ 则一直接受请求. 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. 默认值: 0.

pm.status_path = /status
#FPM状态页面的网址. 如果没有设置, 则无法访问状态页面. 默认值: none. munin监控会使用到

ping.path = /ping
#FPM监控页面的ping网址. 如果没有设置, 则无法访问ping页面. 该页面用于外部检测FPM是否存活并且可以响应请求. 请注意必须以斜线开头 (/)。

ping.response = pong
#用于定义ping请求的返回相应. 返回为 HTTP 200 的 text/plain 格式文本. 默认值: pong.

request_terminate_timeout = 0
#设置单个请求的超时中止时间. 该选项可能会对php.ini设置中的’max_execution_time’因为某些特殊原因没有中止运行的脚本有用. 设置为 ’0′ 表示 ‘Off’.当经常出现502错误时可以尝试更改此选项。

request_slowlog_timeout = 10s
#当一个请求该设置的超时时间后，就会将对应的PHP调用堆栈信息完整写入到慢日志中. 设置为 ’0′ 表示 ‘Off’

slowlog = log/$pool.log.slow
#慢请求的记录日志,配合request_slowlog_timeout使用

rlimit_files = 1024
#设置文件打开描述符的rlimit限制. 默认值: 系统定义值默认可打开句柄是1024，可使用 ulimit -n查看，ulimit -n 2048修改。

rlimit_core = 0
#设置核心rlimit最大限制值. 可用值: ‘unlimited’ 、0或者正整数. 默认值: 系统定义值.

chroot =
#启动时的Chroot目录. 所定义的目录需要是绝对路径. 如果没有设置, 则chroot不被使用.

chdir =
#设置启动目录，启动时会自动Chdir到该目录. 所定义的目录需要是绝对路径. 默认值: 当前目录，或者/目录（chroot时）

catch_workers_output = yes
#重定向运行过程中的stdout和stderr到主要的错误日志文件中. 如果没有设置, stdout 和 stderr 将会根据FastCGI的规则被重定向到 /dev/null . 默认值: 空
&#60;/pre&#62;</content>
			
			
			
			
				
			<category term="article" scheme="http://zotonic.com/id/category" />
		</entry>
	


	
		
	
		<entry xmlns="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005" xml:lang="en">
			<id>http://dhq.me/id/333</id>
			<updated>2013-02-17T16:36:08+08:00</updated>
			<published>2012-12-12T21:36:00+08:00</published>
			<author>
				
				<name>Site Administrator</name>
				<uri>http://dhq.me/id/1</uri>
				
			</author>
			
			<link rel="alternate" type="text/html" href="http://dhq.me/python-count-file-line"/>
			
			
			
			

			<title>python统计特定目录下指定类型文件总行数</title>
			
				<summary>闲时无聊，想看看项目后台代码现有的总行数，也趁好想拿python练练手:^)。<br /><br />程序很简单，主要是先用“os.walk(dir)”获取特定目录下所有文件，再判断文件类型，最后用“enumerate”统计文件行数，以此循环累加出总行数。不多说，上代码</summary>
				<content type="html">&#60;p&#62;闲时无聊，想看看项目后台代码现有的总行数，也趁好想拿python练练手:^)。&#60;/p&#62;&#60;p&#62;程序很简单，主要是先用“os.walk(dir)”获取特定目录下所有文件，再判断文件类型，最后用“enumerate”统计文件行数，以此循环累加出总行数。不多说，上代码：&#60;/p&#62;&#60;pre class=&#34;brush: py&#34;&#62;import os

#要统计的指定目录
dir = &#38;quot;E:/test&#38;quot;
#要统计的文件类型
file_types = (&#38;#39;.erl&#38;#39;, &#38;#39;.hrl&#38;#39;)

def linecount(filepath):
    count = -1
    for count, line in enumerate(open(filepath, &#38;#39;rU&#38;#39;)):
        pass
    count += 1
    return count

def scan_dir(dir):
    num = 0
    for roots, dirs, files in os.walk(dir):
        for file in files:
            name, type = os.path.splitext(file)
            if type in file_types:
                filepath = os.path.join(roots, file)
                num += linecount(filepath)
    print num

if __name__ == &#38;#39;__main__&#38;#39;:
    scan_dir(dir)

&#60;/pre&#62;&#60;p&#62;最后统计出有37多万行的 erlang 代码，相对于&#60;a title=&#34;屌丝VS白富美&#34; href=&#34;http://tech.ifeng.com/internet/detail_2012_06/03/15014401_0.shtml&#34; target=&#34;_blank&#34;&#62;某国白富美90天写代码40多万行&#60;/a&#62;，我们几个后台屌丝一年多时间还没写够40万行代码，情何以堪啊:(&#60;/p&#62;</content>
			
			
			
			
				
			<category term="article" scheme="http://zotonic.com/id/category" />
		</entry>
	


	
		
	
		<entry xmlns="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005" xml:lang="en">
			<id>http://dhq.me/id/330</id>
			<updated>2012-12-13T21:22:25+08:00</updated>
			<published>2012-12-12T21:07:00+08:00</published>
			<author>
				
				<name>Site Administrator</name>
				<uri>http://dhq.me/id/1</uri>
				
			</author>
			
			<link rel="alternate" type="text/html" href="http://dhq.me/ubuntu-install-eaccelerator"/>
			
			
			
			

			<title>Ubuntu 12.04 LTS下安装eAccelerator</title>
			
				<summary>eAccelerator是一个免费开源的PHP加速优化器。它通过缓存PHP代码的编译状态来提高PHP脚本的性能，所以编译的开销几乎为零。同时还优化了代码，加快了代码的执行速度。从而明显减少服务器的负载，使你的PHP代码的执行速度提高1 - 10倍。</summary>
				<content type="html">&#60;p&#62;eAccelerator是什么？下面是它的&#60;a title=&#34;eAccelerator官方网站&#34; href=&#34;http://eaccelerator.net/&#34; target=&#34;_blank&#34;&#62;官方网站&#60;/a&#62;介绍&#60;/p&#62;&#60;blockquote&#62;eAccelerator is a free open-source PHP accelerator &#38;amp; optimizer. It increases the performance of PHP scripts by caching them in their compiled state, so that the overhead of compiling is almost completely eliminated. It also optimizes scripts to speed up their execution. eAccelerator typically reduces server load and increases the speed of your PHP code by 1-10 times.&#60;/blockquote&#62;&#60;p&#62;从上面可知，eAccelerator是一个免费开源的PHP加速优化器。它通过缓存PHP代码的编译状态来提高PHP脚本的性能，所以编译的开销几乎为零。同时还优化了代码，加快了代码的执行速度。从而明显减少服务器的负载，使你的PHP代码的执行速度提高1 - 10倍。&#60;/p&#62;&#60;p&#62;简单的说就是，eAccelerator直接调用编译好的opcode，免除PHP代码的编译开销。&#60;/p&#62;&#60;p&#62;这里假如你在Uuntu上已经安装好了PHP，所以用扩展PHP模块的方式来安装eAccelerator，因此需要用到phpize，而phpize是包含在php-dev里，所以下面一行命令就可以安装phpize：&#60;/p&#62;&#60;pre&#62;apt-get install php5-dev
&#60;/pre&#62;&#60;p&#62;成功安装好后，可以在/usr/bin/目录下找到phpize这个命令。&#60;/p&#62;&#60;p&#62;eAccelerator的源代码可以在其寄管的 &#60;a title=&#34;eAccelerator代码下载&#34; href=&#34;https://github.com/eaccelerator/eaccelerator/downloads/&#34; target=&#34;_blank&#34;&#62;github&#60;/a&#62; 下载:&#60;/p&#62;&#60;pre&#62;wget https://github.com/downloads/eaccelerator/eaccelerator/eaccelerator-0.9.6.1.tar.bz2
tar xvf eaccelerator-0.9.6.1.tar.bz2
cd eaccelerator-0.9.6.1
&#60;/pre&#62;&#60;p&#62;源代码安装：&#60;/p&#62;&#60;pre&#62;phpize
./configure --with-php-config=/usr/bin/php-config --enable-eaccelerator=shared
make
make test
make install
&#60;/pre&#62;&#60;p&#62;安装完后会显示“Installing shared extensions: /usr/lib/php5/20090626+lfs/”，而20090626+lfs这个文件夹就是刚安装好的eAccelerator扩展的存放位置。&#60;/p&#62;&#60;p&#62;打开php.ini（Ubuntu默认是放在/etc/php5/cgi/php.ini），配置eAccelerator，在文件最后加上：&#60;/p&#62;&#60;pre&#62;[eaccelerator]
zend_extension=&#38;quot;/usr/lib/php5/20090626+lfs/eaccelerator.so&#38;quot;
eaccelerator.shm_size=&#38;quot;16&#38;quot;
eaccelerator.cache_dir=&#38;quot;/var/cache/eaccelerator&#38;quot;
eaccelerator.enable=&#38;quot;1&#38;quot;
eaccelerator.optimizer=&#38;quot;1&#38;quot;
eaccelerator.check_mtime=&#38;quot;1&#38;quot;
eaccelerator.debug=&#38;quot;0&#38;quot;
eaccelerator.filter=&#38;quot;&#38;quot;
eaccelerator.shm_max=&#38;quot;0&#38;quot;
eaccelerator.shm_ttl=&#38;quot;0&#38;quot;
eaccelerator.shm_prune_period=&#38;quot;0&#38;quot;
eaccelerator.shm_only=&#38;quot;0&#38;quot;
eaccelerator.compress=&#38;quot;1&#38;quot;
eaccelerator.compress_level=&#38;quot;9&#38;quot;
&#60;/pre&#62;&#60;p&#62;建立eAccelerator的缓存文件夹:&#60;/p&#62;&#60;pre&#62;mkdir -p /var/cache/eaccelerator
chmod 0777 /var/cache/eaccelerator
&#60;/pre&#62;&#60;p&#62;最后，关掉php-cgi进程，重启nginx配置就生效了：&#60;/p&#62;&#60;pre&#62;killall -HUP php5-cgi
/etc/init.d/php-fastcgi start
/etc/init.d/nginx reload
/etc/init.d/nginx restart
&#60;/pre&#62;&#60;p&#62;最后，phpinfo()输出有eAccelerator字样，就算安装完成:)&#60;/p&#62;</content>
			
			
			
			
				
			<category term="article" scheme="http://zotonic.com/id/category" />
		</entry>


		
	
	
</feed>
